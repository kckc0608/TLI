1. 2, 일반 전화기로부터 전화 기능을 상속받고, 사진기능까지 추가한 것이다. 상속을 설명할 때, 유전적 상속처럼 비유하여 설명하였지만, 원숭이로부터 "진화"한게 객체지향 상속으로 보긴 어렵다.
   상속받은 내용물이 시간이 흐르면서 변화한 것이기 때문이다. 객체지향에서 상속받은 내용물은 변화하지 않는다.

2. 1, TV의 세부 종류로 Smart TV가 있다.

3. 3, protected 멤버도 상속된다. 모든 멤버가 상속된다.

4. 모든 선지를 다 보겠다.
(1) 클래스 A의 객체를 생성하고, A의 멤버 w에 직접 접근한다. w는 public 멤버이므로 직접 접근이 가능하다.
(2) 클래스 B의 객체를 생성하고, 상속받은 A의 멤버 w에 직접 접근한다. A를 public으로 상속받았으므로, public 멤버인 A의 w는 상속후에도 public 이다.
    따라서 직접 접근이 가능하다.
(3) 클래스 C의 객체를 생성하고, C의 멤버 y에 직접 접근한다. y는 public 멤버이므로 직접 접근이 가능하다.
(4) 클래스 D의 객체를 생성하고, 상속받은 클래스 A의 멤버 w에 직접 접근한다.
    1. D는 B를, B는 A를 상속하고 있다.
    2. B는 A를 public으로 상속하므로, A의 w가 public으로 상속된다. 따라서 B는 w를 public으로 갖고 있는 상태이다.
    3. D는 B를 protected로 상속하였으므로, B의 public 멤버인 w와 x 를 protected로 상속받는다.
    4. D는 protected 멤버인 w, x를 가지고, public 멤버로 z 를 가진다.
    따라서 w에 직접 접근하는 것은 컴파일 오류가 발생한다.
    
5. B가 A를 private로 상속받고 있으므로, B외부에서는 A로 부터 상속받은 멤버에 접근할 수 없다. B내부에서는 A의 protected 이상 멤버에 접근할 수 있다.
   2, A의 멤버 x는 private이다. 따라서 상속을 받든 뭘하든 A클래스가 아닌 곳에서 직접 접근 불가능.
   
   1, 그냥 상속접근지정인데, 컴파일 오류가 날리가.
   3, B의 private 멤버인 y에 접근중이다. 자기 클래스 멤버니까 private 멤버에 접근 가능하다.
   4, setS를 private로 상속받았다. 애초에 protected 멤버였으므로, B내부에서는 사용가능하다. B외부에서 볼 때, 이 함수는 private 멤버로 보일 것이다.
   
6. B는 A를 protectd로 상속받는다. 따라서 
   A의 멤버 x는 private로 상속받고, B에서는 접근할 수 없다. 외부에서 접근할 수 없다.
   A의 멤버 setX() 는 protected로 상속받고, B에서 접근할 수 있다. 외부에서 접근할 수 없다.
   
   B의 멤버 y는 B에서만 접근 가능하며, 외부에서 접근할 수 없다.
   B의 멤버 setXY() 는 외부에서 접근 가능하다. 이 함수 내부에서는 setX() 함수를 실행할 수 있다.
   
   1, A 클래스의 객체에서 x에 직접 접근할 수 없다. private 멤버이므로 (오류)
   
   2, B 클래스의 객체에서 y에 직접 접근할 수 없다. private 멤버이므로 (오류)
   
   3, A 클래스의 객체에서 setX()에 직접 접근할 수 있다. public 멤버이므로
   
   4, B 클래스의 객체에서 setX()에 직접 접근할 수 없다. protected 멤버이므로 (오류)
   
7. 업캐스팅 = 파생클래스(B)를 기본클래스로 선언하는 것.
   따라서 업캐스팅은 2번
   
   다운 캐스팅 = 기본클래스(A) 타입의 객체를 파생클래스로 선언하는 것.
   따라서 다운캐스팅은 3번
   
   코드상으로 p는 다운캐스팅 되어 B의 객체포인터로 인식되므로, B클래스의 멤버 y에 접근하는 것을 컴파일 오류로 보지 않는다.
   하지만 실제 메모리상으론 p는 멤버변수 y의 공간을 갖고 있지 않으므로, 실행중 이 메모리에 접근할 때, 오류가 발생한다.
   
8. 1) 업캐스팅, 2) 업캐스팅, 3) ..? 상관관계 없으므로 업 캐스팅 아님. 4) 업캐스팅
   객체 D의 멤버는 w, x, z 셋다 모두 public 이다.
   3. ap에 dp를 담으면 어찌됐든 ap는 클래스 A의 포인터형이기 때문에, x 멤버변수에 접근할 수 없다. (컴파일 오류)
   다운캐스팅은 반드시 명시적으로 해야한다.

9. (1) 생성자 A
       생성자 B
   (2) 생성자 A
       생성자 B 10
   (3) 생성자 A 32
       생성자 B 400

10. 클래스 A의 기본생성자가 없기 때문에, 기본생성자가 없다는 컴파일 오류가 발생한다.
    "" 오류 발생 위치는 B() , B(int x) 생성자 구현 부분에서 오류가 발생한다. (컴파일러가 묵시적으로 :A() 를 넣는 위치에서 오류가 발생)
    
    B () : A(20)
    
    B (int x) : A(x + 20)
    
 11. 3, 파생클래스의 소멸자가 먼저실행되고, 기본클래스의 소멸자가 실행된다.
 
 12. 4, 다중 상속시 모호성은 컴파일 시간에 발견된다.
 
 13. class Satellite : public Rocket, public Computer {};
 
 14. (1) class HiPen : public Pen, public Eraser {} ;
     (2) class OmnPen : public Pen, public Eraser, public Lock {} ;
 
 15. 4, power 멤버변수에 접근할 때, 모호성때문에 컴파일 오류가 발생한다. 이 오류는 다중 상속의 모호성 문제로 발생한다.
     Car 클래스도, Airplane 클래스도 power 멤버 변수를 상속받는데, FlyingCar 클래스가 저 두 클래스를 상속받으면 power 라는 같은 이름의 변수 2개를 갖는다.
     따라서 FlyingCar 객체에서 power 멤버변수에 접근하고자 하면 어디에 접근해야하는지 알 수 없기 때문에 컴파일 오류가 발생한다.
     
     이 오류를 해결하기 위해서는 Vehicle을 상속받는 Car, Airplane 클래스가 가상상속을 받도록 virtual 키워드를 추가하면 된다.
     
 16. 역시 나중에 ColorTv, InternetTv를 모두 다중상속받는 클래스가 있을 때, screenSize 변수가 중복되므로 다중 상속의 모호성 문제가 발생한다.
     따라서 virtual 키워드를 사용해 가상상속을 받아야 한다.
   
