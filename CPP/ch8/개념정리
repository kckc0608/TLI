* 상속
===================================================================
부모 클래스 = 기본 클래스
자식 클래스 = 파생 클래스
===================================================================
C++은 다중 상속을 허용한다. 다중 상속시 발생하는 문제가 있음에 유의.

상속은 여러 클래스에서 중복으로 나타나는 코드를 한번만 작성하여, 생산성이 좋을 뿐만 아니라 유지보수에 용이하다.

* 상속 선언
===================================================================
class 파생클래스명 : 상속접근지정자 기본클래스명
{ 클래스 선언부 };
===================================================================
상속을 통해 파생클래스는 기본클래스의 멤버를 자신의 멤버로 확장한다.

* 상속과 접근지정자
===================================================================
** private 멤버도, 상속이 된다. 하지만 파생클래스에서 private 멤버에 직접 접근할 수는 없다.
** 파생클래스는 protected 멤버와 public 멤버에만 직접 접근할 수 있다.
** 당연히도 클래스 외부에서는 오직 public멤버에만 직접 접근할 수 있다. protected, private 멤버에는 접근이 안된다.

*** 업캐스팅
===================================================================
하위단계의 클래스를 상위단계의 클래스로 선언하는 것이다.
Parent 클래스와 Child 클래스가 있다고 해보자.
Parent parent, *p;
Child  child, *c;

p = &child; // 업캐스팅. 하위 단계의 객체를 상위클래스 형태로 선언. 파생클래스 객체를 기본클래스 객체처럼 다룰 수 있도록 한다.
따라서 child 클래스에서 확장된 멤버는 사용할 수 없다. 오직 기본클래스인 parent 클래스 멤버만 사용가능하다.

업캐스팅의 경우, "" 명시적 형 변환이 필요없다. ""
c = &child;
p = (Parent*) c // 이렇게 써도 되지만, 굳이 형변환 필요 없음. (Parent*) child 가 아님에 주의.

*** 다운캐스팅
===================================================================
상위단계의 클래스를 하위단계의 클래스로 선언하는 것이다.
p = &parent;
c = (Child*) p; // 반드시 명시적 형변환을 해야한다.

이 경우, 기존 p는 기본클래스 객체의 포인터였으므로, 파생클래스 멤버에는 접근할 수 없다. (문법적 오류는 없으나, 런타임 에러가 발생한다.)
하지만, 파생클래스 객체를 업캐스팅 한 후, 다시 다운캐스팅을 한다면 멤버에 접근할 수 있다.
캐스팅만으로는 객체의 구성 멤버가 바뀌지 않는다.

* 파생클래스와 기본클래스의 생성자-소멸자 관계
===================================================================
생성자 실행 순서 (컴파일러에 의해 실행)
파생클래스 생성자 호출 -> 기본클래스 생성자 호출 -> 기본클래스 생성자 실행 -> 파생클래스 생성자 실행

소멸자 실행 순서 (생성자 실행 순서와 반대로)
파생클래스 소멸자 실행 -> 기본클래스 소멸자 실행

**** 기본클래스의 생성자가 여러개일 경우 어떤 생성자가 실행될까? ****
===================================================================
원래, 파생클래스의 생성자를 만들 때, 함께 실행할 기본클래스의 생성자를 지정해야 한다.
그러나 명시적으로 지정하지 않는다면, 컴파일러는 기본적으로 기본생성자를 실행하도록 컴파일 한다.

기본클래스와 파생클래스에 대해 "기본생성자 / 매개변수 생성자" 두가지를 따로 생각해보자.
1. 파생클래스의 기본생성자를 호출하는 경우 -> 묵시적으로 기본클래스의 기본생성자를 호출한다.
   " 만약 기본클래스에 매개변수 생성자만 있다면 컴파일 오류가 발생한다."
2. 파생클래스의 매개변수 생성자를 호출하는 경우 -> 기본클래스에 같은형태의 매개변수 생성자가 있더라도, 묵시적으로 기본클래스를 호출한다.
   " 역시 기본클래스에 매개변수 생성자만 있다면 컴파일 오류가 발생한다."

* 명시적인 기본클래스의 생성자 선택
===================================================================
B::B(int x) : A (x + 3) { } 과 같이 생성자 함수 옆에 : 를 붙여 호출할 기본클래스 생성자를 지정한다.
구현부에서 구현한다면 선언부에는 : A(x+3) 부분을 쓸 필요가 없다.

물론 선언부에서 한번에 구현해도 된다.
class A {
public:
	A(int x) { cout << 'A' << x; }
};
class B : public A { 
public:
	B(int x) : A(x + 3) { cout << 'B' << x; };
};

하지만 이런식으로는 못쓴다.
class A {
public:
	A(int x) { cout << 'A' << x; }
};
class B : public A { 
public:
	B(int x) : A(x + 3);
};

구현을 하는 경우에 ": A(x + 3)" 을 쓰는 것이다.

따라서 컴파일러는 묵시적으로 파생클래스 생성자에 : A() 와 같은 기본생성자 호출 코드를 넣는다.
===============================================================================================
******   중요  ******
** 상속접근 지정자 **
상속 접근 지정자는 "기본 클래스 멤버의 접근 지정자의 최대 범위" 이다.

class A {
private:
    int a;
protected:
    int b;
public:
    int c;
};

class B : public / protected / private A {
private:
    int d;
protected:
    int e;
public:
    int f;
};

이렇게 있다고 해보자.
B가 A를 public으로 상속한 경우, 기본클래스 멤버들의 최대 범위는 public이다. 따라서 private -> private / protected -> protected / public -> public
A의 멤버들의 접근지정에는 변화가 없다.

B가 A를 protected로 상속한 경우, 기본클래스 멤버들의 최대 범위는 protected 이다. 따라서 private -> private / protected -> protected / public -> protected
public멤버는 protected 멤버로 제한된다.

B가 A를 private로 상속한 경우, 기본클래스 멤버들의 최대 범위는 private이다. 따라서 private -> private / protected -> private / public -> private
protected, public 멤버는 private 멤버로 제한된다.

** 헷갈리지 말아야 할 것은 "상위 클래스에서 protected 이상이었던 함수"를 "private으로 바꿔서 상속"받은 경우는 클래스내에서 사용할 수 있다.
   자신의 private 멤버로 추가한다는게, 상속받기 전부터 private 이었던 것과는 다르다.
   
   protected 멤버함수 A를 private 상속받아서 private 멤버로 가져온다. => A 는 private 이므로, 상속받아도 직접 호출할 수 없다. (X)
   
   교재 예제 8-6 코드를 가져오면 다음과 같다.
   
class Base {
	int a;                            // 애초부터 private 였던 멤버, 멤버 a는 어떤 식으로 상속을 받은 뭘 하든 죽어도 Base 클래스가 아닌 곳에선 접근 불가
protected:
	void setA(int a) { this->a = a; } // 애초부터 protected 였던 멤버, setA()는 자신을 1회 상속한 클래스 내부까지는 어떤 식으로 상속을 하든 뭘 하든 접근 가능.
                                       그 밖에는 접근 불가능.
public:
	void showA() { cout << a; }       // 애초부터 public 이었던 멤버
};

class Derived : private Base {      // Base 를 private로 가져온다. => a, setA(), showA() 를 private로 상속받는다. 이때, setA(), showA()는 클래스 내부에서 호출 가능.
                                    // setA(), showA()를 "일단 가져온 다음 - > private로 보이도록 바꾼 것" 이지, 애초부터 private였던 것이 아니므로, 사용할 수 있다.
                                    
                                    // private 멤버는 클래스 내부에서 써도 문제 없으니까 setA(), showA() 를 쓸 수 있어! 라는 말은 반만 맞는 말이다.
                                    // a도 private 멤버로 가져오긴 했지만 애초부터 private 였기 때문에, 파생클래스에서 접근할 수 없기 때문이다.
                                    
                                    // 따라서 a 멤버에는 Derived 클래스가 직접 접근할 수 없다. 애초부터 private 였기 때문이다.
                                    // 이후 Derived를 상속하는 클래스나, Derived의 객체입장에서는 a, setA, showA가 private 멤버로 보이므로, 직접 접근할 수 없다.
	int b;
protected:
	void setB(int b) { this->b = b; }
public:
	void showB() {
		setA(5);  // 따라서 호출가능, 컴파일 오류 없음.
		showA();  // 따라서 호출가능, 컴파일 오류 없음.
		cout << b;
	}
};

class GrandDerived : private Derived { // Derived 를 private로 가져옴. => Derived를 가져오는 GrandDerived 입장에서, a, b, setA(), showA() 는 애초부터 private 였다.
                                       // 따라서 private를 상속한들 내용물은 넘어와도 직접 호출 할 수는 없다.
                                       // 반면 protected 였던 setB는 호출할 수 있다. protected로 호출할 수 있는 상태로 가져온 다음, private 멤버로 소속시킨 것이므로.
                                       // 물론 showB() 역시 호출할 수 있다. public 인 멤버함수를 호출 할 수 있는 상태로 가져온다음 private 멤버로 소속시킨 것이다.
	int c;
protected:
	void setAB(int x) {  
		setA(x);  // 따라서 private 멤버를 직접 접근하므로 오류
		showA();  // private 멤버를 직접 접근하므로 오류
		setB(x);  // 이건 가능.
	}
};

**** 만약 상속접근지정자가 생략되면, private 상속으로 처리한다. ****
==========================================================================
** 다중 상속 **
하나의 파생클래스가, 여러개의 기본 클래스를 상속 받는 것이다.
상속받는 기본클래스마다 상속접근지정을 다르게 할 수 있다.

class C : public A, public B {};
이런 식으로 쓴다.

==========================================================================
** 다중 상속의 문제점 **
책의 예제는 조금 더 복잡하게 하긴 했지만..?
class A {
public:
	int mode;
	void showA();
};

class B {
public:
	int mode;
	void showB();
};

class C : public A, public B {
	void showC() {
		mode = 5;
	}
};

이렇게 A, B 두 기본클래스를 다중 상속받는 C 클래스가 있다고 할 때,
A, B 클래스에 같은 이름의 멤버 변수 mode 가 있다면, C클래스는 해당 변수를 어떤 클래스의 변수로 인식할까?
모호하므로 컴파일 오류가 발생한다.

이 문제를 해결하려면 virtual 키워드를 이용해 가상 상속으로 상속을 받아야 한다.

class Base {
public:
	int mode;
};

class A : virtual public Base{
public:
	void showA();
};

class B : virtual public Base{
public:
	void showB();
};

class C : public A, public B {
	void showC() {
		mode = 5;
	}
};

void test2() {
	C c;
	c.mode;
}

다음과 같이 클래스를 예제와 같이 수정하고 볼 때, A, B는 "가상 기본 클래스 Base 를 상속받는다." 라고 하거나 "Base를 가상상속 받는다." 라고 한다.

==================================================================================================================
virtual 키워드 : 컴파일러에게 파생 클래스의 객체가 생성될 때, 기본클래스의 멤버공간을 오직 한번만 할당하고, 
                 이미 할당되어 있다면 그 공간을 공유하도록 지시한다.
==================================================================================================================

따라서 c 객체를 생성하면
1. showC() 만들고
2. A를 상속받으면서 showA() 만들고
3. Base를 가상상속받으면서 Base의 mode를 가상상속으로 만들고
4. B를 상속받으면서 showB() 만들고
5. Base를 다시 가상상속 받을 때, Base의 mode가 이미 있으므로 상속을 받지 않는다.
==================================================================================================================
class Base {
public:
	int mode;
};

class A : public Base {
public:
	void showA();
};

class B : public Base {
public:
	void showB();
};

class C : virtual public A, virtual public B {
	void showC() {
		mode = 5; // 컴파일 오류
	}
};

그러나 이렇게 하면 오류가 발생한다.
왜냐하면 A와 B는 이미 둘다 mode라는 변수를 똑같이 상속 받은 후, 이 둘은 둘다 mode 변수를 상속받은 별개의 클래스 이기 때문에, 
가상상속 받더라도 mode 라는 이름이 다른 클래스의 것이므로, 중복해서 상속을 받기 때문이다.
