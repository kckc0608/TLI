런타임 에러의 종류와 원인
1. 개발자의 논리가 잘못된 경우
2. 예상치 못한 입력에 대해 대비가 되어있지 않은 경우 -> 사용자의 예상치 못한 입력을 걸러내도록 코딩해야함

예상치 못한 상황 = 예외 (Exception)

* 운영체제는 하드웨어나 시스템 자원을 다루는 중에 발생하는 예외를 응용프로그램에게 알려주는 예외 처리 기능을 따로 두고 있다.
  => 운영체제가 탐지한 에러를 처리하고자 하면 운영체제 API를 이용하여야 하며, 운영체제 메뉴얼에 실린 별도 프로그래밍 방법으로 코딩해야 한다.
 
 기본 형식 : try-throw-catch
 
 try { 
    예외 발생 가능성이 있는 코드 
    if (예외 발생시)
      throw 예외값;
 }
 
 catch (처리할 예외값 파라미터) {
  예외 처리문.
 }
 
 catch (처리할 예외값 파라미터) {
  예외 처리문.
 }
 
 try 블록에 예외 발생 소지가 있는 코드를 넣고, 예외를 처리할 catch () 블록을 "" try 블록 바로 다음에 연결하여 "" 선언한다. (아니면 컴파일 오류 발생)
 
 try 문에서 예외 발생시 throw 코드에 의해 예외를 던지게 되며, 이 예외값을 처리하는 catch 코드가 있어야 한다. (없으면 프로그램이 종료됨. 컴파일 오류는 X)
 throw가 실행되면, 남은 try코드를 무시하고 바로 해당하는 catch 문으로 이동한다.
 
 catch 블록에서 예외 파라미터는 " 1개만 " 선언 가능하다. (여러 종류의 예외를 한번에 받고 싶다면, 예외 클래스를 만들고, 업캐스팅해야할듯하다)
 하나의 try문에는 여러개의 catch를 붙일 수 있다. (다양한 타입을 처리할 수 있다.)
 try문 내부에 작성된 함수에서 throw를 던지면, "어떤 값도 리턴하지 않고", 함수가 호출된 try문에 연결된 catch로 이동한다.
 
 예외값은 다양한 타입을 가질 수 있다. (객체도 가능)
 
 예외의 구분은 "타입" 으로 하며, catch 문은 타입을 잡아 해당 타입에서 값 별로 다르게 예외처리를 할 수 있다.
 
 try {
    throw 3;
 }
 
 catch (int x) {
 }
 
 C-string 문자열을 던지면, const char * 타입으로 잡는다.
 
 throw 문을 가지는 함수는, 함수 선언문에 예외 발생을 명시할 수 있다.
 발생하는 모든 타입을 명기하면 된다.
 
 void f() throw(int, char*) {...}  이런식으로 쓸 수 있다.
 의무사항도 아니고, 안한다고 오류가 나오는 것도 아니지만, 프로그램 작동을 명확히하며, 프로그램의 가독성을 높이는 코드이므로 좋다.
 
 ** catch 문 내부에 '...' 을 넣으면 어떤 예외라도 포착할 수 있다. 이 경우, 해당 catch문은 마지막 catch문 블록이 되어야 한다.
 catch(int x) {}
 catch(...) {} // int 타입은 위에서 처리, 그밖의 타입은 여기에서 처리
 
 ** try 문의 중첩
 내부 try문의 throw문은 해당 try문 외부에 선언된 catch문에서 처리되어야 한다. 하지만 만약 그 외부 try문 내부에 catch 문이 없다면
 외부 try문의 catch문으로 예외가 전달된다.
 
 * throw 문은 반드시 try문 내부에서 사용되어야한다. 그렇지 않으면 abort() 함수를 호출하여 프로그램을 종료시킨다.
 
 throw 3; // 이게 실행된 순간 abort() 함수가 호출되며 프로그래 종료
 
 try { }
 catch (...) {}
 
 * catch문 내부에서도 try-catch 문을 사용할 수 있다.
 
 * 예외 '클래스' 만들기
 MyException 클래스를 만들고, 해당 클래스를 상속하는 구체 예외상황 클래스를 만든다.
 그리고 throw 문에서 해당 클래스 객체를 호출하는데, 책에서는 다음과 같이 호출한다.
 
 throw ExceptionClass(line_num, func, err_msg); // 임시 객체를 생성하여 throw 한다. // 객체를 변수에 담고 변수를 넣지 전달하지 않아도 던지기 가능.
 
 예외 캐치문은 다음처럼 참조를 활용했다.
 
 catch ( ExceptionClass & e) {}
 
 
 *** 중요 !! ***
 C 코드와 C++코드의 링킹
 
 C코드와 C++ 코드는 컴파일하여 목적코드를 만들때, 소스코드의 변수,함수,클래스 명을 변형하여 저장하는데, 컴파일러마다 변형 방식이 다르다.
 C컴파일러 : 함수이름앞에 _ 를 붙인다. ( void f(); => _f 로 변형하여 목적파일에 저장, return 타입과 매개변수 존재여부는 신경쓰지 않는다. 오버로딩이 없기 때문. )
 따라서 이 이름을 기준으로 서로 다른 소스파일에 존재하는 함수를 링킹한다.
 
 C++컴파일러 : 함수의 매개변수개수, 타입, 리턴타입등을 참조하여 복잡한 기호를 포함하는 이름으로 변형한다. 따라서 함수오버로딩, 함수재정의가 가능하다.
               하지만 예외적으로 main함수는 C와 마찬가지로 항상 _main으로 변형한다. (메인은 하나의 프로그램에 하나만 존재하므로)

따라서 C코드를 C++소스코드에 그냥 호출하면 링킹시 문제가 발생한다. (이름을 명명하는 규칙이 다르기 때문.)
또한 이 이름 명명 규칙은 정해진 것이 없어 컴파일러마다 규칙이 다르다. 따라서 서로 다른 컴파일러로 컴파일된 목적코드는 서로 링킹이 안된다.

이 링크 오류를 해결하기 위해 다음과 같이 선언한다.

extern "C" 함수 원형;
또는

extern "C" {
함수 원형 1;
함수 원형 2;
함수 원형 3;
}

그럼 해당 함수 원형들은 C의 방식으로 네이밍한다. 목적코드를 만든다.
또는 이 원형들이 선언된 소스코드 파일을 통째로 지정할 수 있다.

extern "C" {
  #include "myFunc.h"
}



 
 
