1. 1
2. 2, 함수 오버라이딩
3. 3
4. 다형성
5. (1) 기본클래스 : Base, 파생클래스 : Derived
   (2) Derived::f() called
   (3) Base::f() called
   (4) Base::f() called
   (5) Base::f() called
   
   가상함수가 아니므로, Base 포인터를 사용해 실행한 f는 전부 Base::f() called를 출력한다.
6. (1) 1, 2, 3
       virtual은 상속되므로, A의 func() 를 제외하고 모두 가상함수.
   (2) C::f() called
   (3) C::f() called
   (4) C::f() called
   (5) C::f() called // 여기가 중요하다. 비록 func() 는 가상함수가 아니지만, 함수 내부에서 가상함수를 호출하고 있으므로 동적바인딩에 의해 C가 호출된다.
       가상함수에 대해서 동적바인딩이 일어나고 있는 f에 대해서 A::f() 와 같이 범위지정 연산자를 쓰지 않은 한, 모든 f()는 C의 f()로 호출된다.
       (그래서 '동적 바인딩' 이다. 실행시간 중 f를 만나면 죄다 C의 f()로 돌려버리는 것.)
       즉 가상함수의 호출과 바인딩은 클래스 내부 외부에 상관이 없다.

7. 동일한 이름의 변수나 함수가 여러 곳에 선언되었을 때, 가장 가까운 범위에 선언된 이름을 사용하는 규칙을 컴퓨터 언어 이론에서 '범위 규칙' 이라고 한다.
   범위 지정 연산자를 사용하면 클래스 멤버와 동일한 이름의 외부 함수를 클래스 내에서 호출할 수 있다.
   
8. (1) ::f();
   (2) A::f();
   (3) f();

9. 소멸자는 동적바인딩이 되고, 2, 소멸자는 가상 함수로 선언하는 것이 바람직하다.
   소멸자를 가상함수로 선언하면 동적바인딩이 일어나고, 생성자는 가상함수로 선언할 수 없다.

10. (1) id=10
        delete p를 할 때, Studnet 클래스의 소멸자가 실행되지 않고, Person 클래스의 소멸자만이 실행되어, name 동적 배열의 메모리 반환이 이루어지지 않는다.
    (2) Person 클래스의 소멸자를 가상함수로 선언한다.

11. 3

12. 3 프렌드가 아니다. 외부 함수를 순수 가상함수로 선언할 수는 없다. (애초에 외부 함수는 구현이 되어있는데?)

13. 2

14. (1) 1, 추상클래스는 객체를 만들 수 없다.
        3, 추상클래스를 상속한 후, 순수가상함수를 구현하지 않은 클래스도 추상클래스다. 따라서 객체를 생성할 수 없다.
    (2) Circle에서 draw() 함수를 구현하면 된다. 
        void draw(); 선언 후
        void Circle::draw() { cout << "반지름=" << radius << "인 원" << endl; }
 
15. 4, 순수가상함수 호출시 동적바인딩이 일어나므로 컴파일시 바인딩이 일어나지 않는다.
