* 상속과 함수 재정의
======================================================================================
파생클래스는 기본클래스의 함수를 그대로 가져다 재정의해서 사용할 수 있다.

class Base {
public:
  void f() { cout << "Base::f() called" << endl; }
};

class Derived : public Base {
  void f() { cout << "Derived::f() called" << endl; } // function redefine
};

int main() {
  Base b, *pBase;
  Derived d, *pDerived;
  
  pBase = &b;
  pDerived = &d;
  
  b.f(); // Base::f() called
  d.f(); // Derived::f() called
  
  // 파생클래스에서 기본클래스의 함수를 재정의 하면, 재정의한 함수가 호출된다.
  
  pBase = %d; // 업캐스팅.
  pBase->f(); // Base 클래스의 f가 호출됨. Base::f() called
  
  // 업캐스팅하면, 업캐스팅한 해당 클래스의 f가 호출된다.
  // 이러한 호출 관계는 "컴파일 시" 결정되며, 이를 "정적 바인딩" 이라고 한다. (고정된 연결)
  
  pDerived->Base::f(); // 범위지정 연산자를 활용해서 기본클래스의 함수를 호출할 수 있다. Base::f() called
}
======================================================================================
* 가상함수와 오버라이딩
======================================================================================
오버라이딩-> 덮어서(over) 올라타는(riding) 느낌으로 이해해보자. 기존 함수를 덮는 것이다.
오버라이딩은 기본 클래스에 작성된 "가상함수"를 재작성하여, 기본클래스의 함수를 "무력화"시키고,
파생클래스의 함수가 주인 노릇을 하는 것이다.

=> 오버라이딩을 하게되면 기본클래스의 포인터이든, 파생클래스의 포인터이든, ""언제나 파생클래스의 함수가 호출""된다.

가상함수 -> virtual 키워드를 맨 앞에 추가로 붙인 함수이다. 가상상속이 한번 상속한 요소를 중복해서 상속하지 않게 하는 것이라면,
            가상함수는 "자신에 대한 호출바인딩을 실행 시간까지 미루도록 하는 지시어" 이다.

오버라이딩은 기본클래스의 "가상함수"를 재작성하는 것이고, 이를 특별히 "함수 오버라이딩" 이라고 부른다.

- 함수 재정의 (redefine)      => 컴파일 시간 다형성, 정적 바인딩
- 함수 오버라이딩 (overiding) => 실행 시간 다형성, 동적 바인딩, 늦은 바인딩 (late binding), 실행시간 바인딩 (run-time binding)

따라서 만약 f()가 가상함수로 선언되었다면
virtual void f();
pBase = pDerived;
pBase->f();       // 비록 pBase 이지만, 동적바인딩이 일어나 Dervied::f() called

* 오버라이딩은 리턴타입까지 완벽하게 함수 원형이 일치해야한다. 리턴타입이 다르면 오버라이딩이 되지 않는다.
* "" 가상함수의 virtaul 키워드는 상속 된다 "" 따라서 파생클래스의 가상함수에는 virtual 키워드가 필요없다.

* 범위 지정자를 활용해, 오버라이딩된 함수라도 정적 바인딩하여 호출할 수 있다. 
  ( // Shape* pShape = new Circle(); // 이건 컴파일 오류 발생
   Shape* pShape; Circle c; pShape = (Shape*)&c; // Shape * pShape = &c; 이것도 컴파일 오류, 선언과 동시에 대입할 때 묵시적 업캐스팅은 안됨. 명시적은 됨.
   pShape->Shape::draw(); // 정적바인딩으로 Shape의 draw() 호출)

* 변수는 오버라이딩이 없다.
* C++에서는 Java와 달리 함수재정의와 함수오버라이딩이 구분된다. Java는 함수 재정의라고 해도 함수 오버라이딩을 의미한다.
* 오버라이딩을 통해, 파생클래스는 기본클래스의 가상함수를 재정의 한다.
  이를 통해, 가상함수를 일종의 '인터페이스'로 보고, 파생클래스에서 구현해야할 요소로 인식하게 할 수 있다.
======================================================================================
* 동적바인딩
======================================================================================
동적바인딩은 "파생클래스 객체에 대해, 기본클래스의 포인터로 '가상 함수'가 호출될 때" 일어난다.

class Shape {
public:
  virtual void draw();
};

class Circle : public Shape {
public:
  virtual void draw() {
    cout << "circle drawed" << endl;
  }
};

class Rect : public Shape {
public:
  virtual void draw() {
    cout << "rect drawed" << endl;
  }
};

void paint(Shape * s) { s->draw(); }

int main() {
  paint(new Circle); // circle drawed
  paint(new Rect);   // rect drawed
}

======================================================================================
* overide 지시어 -> 파생클래스의 오버라이딩한 함수 이름 뒤에 적는다. void draw() overide; 
                    제대로 오버라이딩이 됐는지 (상위 클래스에 동일명의 함수가 있는지) 확인.
* final 지시어 -> 함수 이름뒤에 붙이면 오버라이딩 할 수 없다. 클래스 뒤에 선언하면 해당 클래스를 상속할 수 없다.
* 범위지정연산자 ::의 활용 -> 클래스의 멤버함수와 외부 함수의 이름이 같을 때, 클래스 내부에서 ::f(); 는 외부함수 호출, f(); 는 클래스 멤버함수 호출.
                             클래스의 멤버변수와 전역 변수의 이름이 같을 때, 클래스 내부에서 ::n; 은 전역변수 호출, n은 클래스 내부 변수 호출.
======================================================================================
* 가상소멸자
소멸자는 가상함수로 작성하는 것이 좋다.
만약 가상함수로 작성하지 않고, 기본클래스와 파생클래스의 가상함수를 모두 작성하였다고 해보자.
만약 파생클래스를 기본클래스 포인터로 접근한 상태에서 delete 연산자를 쓸 경우, => 기본클래스의 소멸자만 실행된다.
가상함수로 소멸자를 쓰면, 동적바인딩이 일어나 파생클래스의 소멸자가 실행된다.  => """" 파생클래스의 소멸자가 실행 -> 기본클래스의 소멸자가 실행 """"

따라서 가상 소멸자를 작성하는 것이 안전하다.

* 생성자는 가상함수가 될 수 없고, 생성자에서 가상함수를 호출해도 동적바인딩이 되지 않는다.

======================================================================================

오버로딩 => 중첩해서 'load' 하는 것, 덮는게 아니라 추가로 얹는 것이다. 이름이 같지만 매개변수 타입, 개수가 다른 함수를 추가로 선언하는 것.
            컴파일 타임에서 중복 함수의 호출을 구분하는 '정적바인딩'
함수재정의 => 기본 클래스의 멤버함수를 파생클래스의 멤버함수가 덮어 쓰는 것. 객체 포인터 타입에 따라 호출 함수가 결정되는 '정적 바인딩', 컴파일 타입에 결정.
함수 오버라이딩 => 중첩해서 'rideing' 하는 것, 덮는 것이다. 객체 포인터 타입에 무관하게, 실제 가리키는 객체의 원래 타입에 따라 가리키는 함수가 동적 결정.
                  '동적 바인딩', '런타임 바인딩' 기본클래스의 가상함수를 재정의할 때 일어난다.

======================================================================================
* 순수 가상함수 => 기본 클래스에 작성된 가상함수로, 함수의 코드가 없고, 선언만 있는 가상함수 (코드를 작성할 수 없다.)
                   virtual f() = 0; 형태로 선언한다.
* 추상 클래스   => 하나 이상의 순수 가상함수를 가진 클래스를 '추상 클래스' 라고 한다. (순수 가상함수로만 구성된 클래스만을 일컫지 않음에 주의. 자바와 다르다)

* 추상 클래스는 구현 코드가 없는 함수를 갖고 있기 때문에 불안정 하다. => 객체를 생성할 수 없다.
  하지만 포인터는 선언할 수 있다.
  
여러종류의 파생클래스를 동시에 지칭하거나, 파생클래스의 인터페이스 역할을 한다.

* 추상 클래스를 상속한 클래스도 추상 클래스가 된다.  따라서 이 클래스도 객체를 생성할 수 없다.
* 추상 클래스의 모든 순수 가상함수를 오버라이딩하여 구현하면 더이상 추상클래스가 아니게 되므로, 객체를 생성할 수 있다.
