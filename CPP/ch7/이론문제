1. 1, 한 클래스의 전체 멤버함수를 클래스로 선언할 수 있다. friend className; 으로 선언한다. 프렌드함수는 멤버함수는 아니다.
2. 4, 함수 중복시에 프렌드 함수가 반드시 필요하지는 않다.
3. friend SampleManager;
4. friend bool Sample::compare(Sameple &a, Sample &b);
5. bool isValid(Student s) 는 외부함수이다. 이 외부함수의 매개변수로 들어온 Student 클래스의 객체 s에서 id 멤버에는 직접 접근할 수 없다.
   따라서 클래스 내부에 이 함수를 프렌드함수로 초대해야한다.
   friend bool isValid(Student s);
   코드를 추가한다. 
   *** 프렌드 함수를 쓸 때는, 해당 함수가 클래스 선언 이전에 선언되어 있지 않아도 괜찮다.
6. 5번 문제와 마찬가지로, s와 p의 private 멤버에 직접 접근할 수 없다. 따라서 Student 클래스와 Professor 클래스에 이 함수를 멤버함수로 추가한다.
   이때 전방참조 문제와 전방선언을 주의해야 한다. 5번과 달리 전방참조와 전방 선언이 필요한 이유는 Student 클래스를 선언하고, Professor 클래스를 선언할 경우,
   Professor 클래스에서는 Student 클래스가 선언되어 있어 전방참조의 문제가 없지만, Student 클래스에서는 매개변수로 아직 선언되지 않은 Professor 클래스를
   사용하고 있기 때문이다.
   
   프렌드 함수를 사용할 때 함수 이름에 대해서는 전방참조의 문제가 발생하지 않는다.

7. (!!중요!!)
   Person 클래스에서 food 객체의 private 멤버 price 에 직접 접근하고 있기 때문에 오류가 발생한다. 
   따라서
   1. Food 클래스에 Person클래스의 void shopping(Food food) 함수를 프렌드로 추가한다.
   
   그러나 문제에서는 Person 클래스가 Food 클래스보다 나중에 선언되어 있기 때문에 Food를 전방선언하더라도
   void Food::shopping() 함수를 찾을 수는 없다. 따라서 
   2. 클래스의 선언 위치를 바꿔주어야 한다.
   
   그러면 이번엔 Person 클래스에서 매개변수에 들어온 Student 클래스를 인식하지 못하기 때문에, Student 클래스를 전방참조하는 문제가 발생하고
   이를 해결하기 위해 
   3. Student 클래스의 전방 선언을 해주어야 한다.
   
   하지만 이걸로는 아직 끝나지 않았다..!!!
   현재 클래스 선언부안에 함수를 구현했는데, 함수 구현과정에서 s.id 멤버를 접근하고 있다.
   전방선언만으론 s.id에 접근할 수 없기 때문에, 
   4. 해당 부분을 따로 빼서 구현부로 만들어야 한다.
   
8. 4, 프렌드함수는 클래스의 멤버함수가 아니기 때문에 어디에 선언해도 괜찮다.

9. 저렇게 프렌드로 선언과 동시에 구현하면 외부함수를 구현하는 것과 동시에 프렌드 함수로 추가하는 역할을 하게 된다. (문제 있는 코드는 아니다.)
   이 함수는 클래스 내부 멤버가 아니므로, a.izZero() 로 호출 할 수 없다. (이게 핵심!!)
   문제가 있는 것은 아니지만, 프렌드로서 의미가 있으려면 x 멤버를 private로 선언하는 것이 좋다.

10. a.x의 x멤버가 public이므로 프렌드함수 없이도 접근할 수 있다. 따라서 굳이 선언하지 않아도 괜찮다.

11. 연산자 오버로딩을 보여주고 있다. << 연산자를 오버로딩하여 기존 의미대로 정수 시프트 연산에 사용하거나, cout 객체의 연산자로 오버로딩 해서 사용하는 것을 보여주고 있다.

12. 책+갈피 = 책갈피

13. 4, 어떤기호든지 가능한 것은 아니다. 정해진 연산자만 오버로딩할 수 있다.

14. 4, 왼쪽 피연산자가 자기 객체인 경우에만 클래스에 대해 연선자 함수를 작성할 수 있다.

15. 3, += 연산자는 리턴타입이 자기자신 클래스의 참조형이어야 한다.

16. Power a 가 아니라 Power& a 이다. 후위연산자이므로, 리턴타입에는 참조가 없어야 하며, 후위 연산자는 int형 매개변수가 추가로 들어간다.

17. 치환연산자를 작성할 필요가 없다. 포인터형 멤버가 없기 때문에 비트단위로 객체를 복사해 넣는 치환연산시 문제가 없다.
