friend 키워드 => 클래스 외부의 함수나, 외부 클래스 자체를 자신의 멤버인 것처럼 초대하는 것. 
                 해당 키워드로 가져온 함수는 클래스 내부의 모든 멤버에 접근가능.

1. 클래스 외부에 작성된 함수
2. 다른 클래스의 멤버함수
3. 다른 클래스의 모든 멤버 함수

이 3가지 경우의 함수를 가져올 때, friend 키워드로 가져올 수 있다.

객체에 프렌드 함수로 넣을 함수가 해당 객체를 매개변수로 갖는 경우,
객체에 함수를 넣기 위해서는 함수가 미리 선언되어야 있어야 하므로 Class가 선언되기 전에 해당 함수를 선언하면서
아직 구현하지 않은 클래스를 사용하게 된다. (전방 참조 문제)

이 문제를 해결하기 위해 "전방 선언"을 해야한다. class 해당클래스명; 으로 짧게 클래스 이름만 선언하고 넘기는 것으로 문제를 해결한다.

예제 7-1 에서는 외부 함수를 클래스 내 프렌드 함수로 선언하는 것을
예제 7-2 에서는 외부 클래스의 멤버 함수를 자신 클래스 내 프렌드 함수로 선언하는 것을 보여준다.
friend returnType ForignClass::ForignFunction() 형태로 선언한다.

예제 7-3 에서는 외부 클래스의 모든 멤버 함수를 자신 클래스 내 프렌드 함수로 선언하는 것을 보여준다.
friend ForignClass; 형태로 선언한다.

**** 연산자 중복 ****
1. 본래있는 연산자만 중복 가능 (일부 제외 : ., .*, ::, ? :) 예를 들어 ** 는 연산자 중복 안됨. (* 를 중복해서 2번 사용할 수는 있겠으나..)
2. 피연산자 타입이 다른 연산을 새로 정의하는 것으로, 반드시 클래스와 연결되며, 피연산자의 개수를 변경할 수 없다.
3. 연산자 우선순위를 바꿀 수 없으며, 연산자 중복은 함수를 통해 이루어진다.

연산자 중복 선언
리턴타입 operator 연산자 (매개변수리스트) { 구현 내용 } 으로 선언

연산자 중복 선언 위치
1. 외부함수로 구현 후, 클래스에 프렌드함수로 선언
2. 클래스 멤버함수로 구현 (이 경우, 왼쪽 피연산자는 반드시 해당 클래스의 객체여야 함)

<1> 이항 연산자 중복
클래스 내부 + 연산자 오버로딩 선언 : Power operator + (Power op2);
구현 
Power Power::operator+(Power op2) {
	return Power(this->kick + op2.kick, this->punch + op2.punch);
}

c = a + b; 가 컴파일러에 의해 c = a.+(b); 로 바뀜. (+라는 이름의 a의 멤버함수를 호출하고 b를 매개변수로 넘김)
이때, 매개변수에 참조 매개변수를 사용해도 된다. 단, 원본 객체의 변경에 주의해야 한다.

** += 재정의 하기 **
+ 나 == 과 같은 이항연산자와 달리, 기존 객체 자체가 변화하는 연산자이므로 반환형은 "자기 자신의 참조"여야한다.
Power& Power::operator+=(Power op2) {
  this->kick += op2.kick;
  this->punch += op2.punch;
  return (*this);    // 이게 핵심!
}

** 단항 연산자 중복 **
* ++ 전위 연산자 중복하기. *
전위 연산자를 중복할 때는, "객체 자신에 변화를 주고, 변화한 자신을 리턴해야 한다."
따라서 반환형은 자기 자신의 참조이다.
Power& Power::operator++() {  // 매개변수는 없음!
  this->kick++;
  this->punch++;
  return *this;
}

* ++ 후위 연산자 중복하기!!! *
전위 연산자와 후위 연산자는 모두 단항연산지이다. 따라서 이 둘을 구분하기 위해 후위연산자는 의미없는 값이 들어가는 int형 매개변수를 갖는다.
그리고 후위연산자는, 자기 자신에는 변화를 주고, 변화하기이전의 자신을 돌려주어야 하기 때문에 반환형은 "참조가 아닌 그냥 자료형이다"
Power Power::operator++(int n) {
  Power tmp = *this; // 변화하기 전 자신을 미리 복사해둠.
  this -> kick++;
  this -> punch++;
  return tmp; // 변화하기전 자신을 리턴.
}

* 외부함수로 연산자함수를 작성하여 friend 함수로 클래스에 넣어주는 경우
2 + a 의 경우 컴파일러는 2.+(a);로 바꾸겠지만, 2는 객체가 아니므로 잘못된 식이다. 따라서 이런 경우엔 외부함수로 연산자를 따로 정의하고,
해당 함수를 클래스에 friend로 넣어주어 클래스 내 멤버에 자유롭게 접근할 수 있도록 해주어야 한다.
그래서 이 경우 컴파일러는 해당 식을 다음과 같이 바꾼다.
+ (2, a)

Power operator+(Power op1, Power op2) { return Power(op1.kick + op2.kick, op1.punch + op2.punch); }
클래스 내부에는
friend Power operator+(Power op1, Power op2); 를 선언.

++ 전위 연산자를 외부 함수로 쓰는 경우
Power& operator++(Power& op1) { // 매개변수에 참조가 들어가야 한다. 직접 객체 내부를 변경하는 것이기 때문!
    op1.kick++;
    op1.punch++;
    return op1;
}

++ 후위 연산자를 외부 함수로 쓰는 경우
Power operator++(Power& op, int x) { // 매개변수에 참조가 들어가야 한다. 직접 객체 내 부를 변경하는 것이기 때문!
    Power tmp = op;
    op.kick++;
    op.punch++;
    return tmp;
}

<< 연산을 위해 참조를 쓰는 경우
a << 3 << 5 << 6;
이 코드를 위해 연산자를 정의할 땐
Power& operator << (Power& op, int x) {
    op.kick += x;
    op.punch += x;
    return op;
}
이렇게 써야한다.
만약 반환형이 참조형이 아니라면, 처음 3은 객체에 잘 더해지겠지만, 더해진 결과값이 복사되어 리턴되고, 그 리턴된 복사본에 5를 더하고,
5를 더한 결과를 복사한다음, 그 복사본에 6을 더하게 된다.
결과적으로 a에는 3만이 더해지게 된다. (3이라도 더해지는 이유는 매개변수가 참조이기 때문이다. 만약 매개변수가 참조가 아니라면 애초에 객체에 변화가 안일어난다.)
