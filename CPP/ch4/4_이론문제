1. 
(1) Rect * p;
(2) p = &r;
(3) cout << p->getWidth() << ' ' << p->getHieght();

2.
(1) q = new Rect(w, h);
(2) cout << q->getArea();
(3) delete q;

3. 1, 기본 생성자가 없으므로 컴파일 오류가 발생한다.

4. Rect 클래스에 기본 생성자를 추가해야 한다. 동적으로 배열을 만들 때 역시 기본생성자가 호출된다.

5.
int sum = 0;
for (int i = 0; i < 5; i++) {
  sum += r[i].getArea();
}
cout << sum;

6. 4

7. 4, delete [] c; 코드로 배열 c를 소멸해야 한다.

8.
기본생성자
기본생성자
기본생성자
소멸자
소멸자
소멸자

9. 1, new와 delete 는 기본 연산자 이다.

10. 동적으로 생성한 객체 배열의 메모리를 반환하기 위해서는 delete [] p; 로 써야한다.

11. 3, static 함수를 포함할 수 없다.

12. 3, 생성자에서도 this는 사용할 수 있다.

13. this->width = this->height = 0;
    this->width = w; this->height = h;
    cout << this->width << this->height << endl;

14. 동적 할당으로 생성한 객체를 가리키는 포인터가 다른 객체의 주소를 가리키게 되었을 때, 기존 객체를 더이상 가리킬 수 없어 메모리 누수가 발생한다.

15. 
(1) 메모리 누수가 발생한다. 함수가 종료되어도, new 연산으로 생성된 객체 배열은 자동으로 사라지지 않는다. delete [] p; 연산자를 추가해야 함.
(2) 메모리 누수가 발생하지 않는다. q 포인터가 p포인터가 가리키는 객체의 주소를 동일하게 가리키고 있으므로, delete q 를 하면, 해당 메모리를 반환하기 때문이다.
(3) 메모리 누수가 발생하지 않는다. 배열을 동적으로 생성하지 않았으므로, 함수가 종료됨과 동시에 배열에 할당된 메모리가 반환된다.
(4) 메모리 누수가 발생한다. p에 새로운 객체를 동적으로 생성한 뒤, 같은 포인터 변수 p에 또다른 객체를 동적으로 넣었기 때문에, 기존에 만든 객체는 더 이상 가리킬 수 없다.
    delete p; 를 반복문 내부로 넣어야 한다.

16. 1

17. stoi

18. 3, 스트링은 c++ 표준이다. / string 객체에는 문자를 조작하는 기능이 없어, locale 헤더를 추가하여야 한다.

19. string a = "My name is Jane.";
    char ch = a[2];
    if(a == "My name is John.") cout << "same";
    a += "~~";
    a[1] = "Y";
    
    // a.compare(b) 에서 a가 b보다 사전순으로 앞서면 음수, 뒤에 있으면 양수를 리턴한다.
