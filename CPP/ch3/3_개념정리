캡슐화 : 객체의 구성 요소들을 캡슐(클래스)로 싸서 보호하고 볼 수 없게 하는 것. But 객체간 정보 교환과 상호 통신을 위해 일부가 노출되어 있음 (public)
클래스 : 객체의 정의 틀 / 설계도
객체   : 클래스 틀에서 찍어낸, 실제 멤버 변수 메모리와 멤버 함수를 가지고 실존하는 인스턴스

클래스 선언부 (보통 헤더파일(.h)로 분리)
class A {
public:
  ~~
  void f();
};

클래스 구현부 (보통 소스파일(.cpp)로 분리)
void A::f() {
  ~~
}

* 멤버변수는 클래스 선언부에서 초기화 가능 (C++11)
* 클래스의 디폴트 접근 지정자 = private
* 객체가 생성되면, 객체를 생성한 함수의 스택에 객체가 존재한다.

생성자 : 객체를 생성할 때, 객체를 초기화하는 특별한 멤버함수. 하나의 클래스에 여러개의 생성자가 존재 가능, 실행은 하나만 된다. Constructor
         return 타입은 명기하지 않으며(명기시 컴파일 오류), 클래스 이름과 동일한 함수를 선언한다.
         * 객체를 사용하기 전 필요한 초기작업 수행 (변수 초기화, 메모리 동적할당, 파일 열기, 네트워크 연결 등 작업)
         * 생성자는 1번만 실행된다.
생성자를 여러개 생성할 경우, 매개변수 타입/개수가 달라야 한다.

Circle donut;     // Circle() 실행
Circle pizza(30); // Circle(30); 실행

** 위임생성자 : 생성자가 다른 생성자를 호출하는 경우
생성자를 구현시 ':' 를 활용해 다른 생성자를 호출한다.

Circle::Circle() : Circle(0) {}
Circle::Circle(int x) : Circle(x+2) {} // '위임생성자'에서 선언한 매개변수를 '타깃생성자'에서도 사용가능하다.
                                       //  코드의 실행은 '타깃생성자'가 실행된 이후 '위임생성자'가 실행된다.

* 멤버 변수의 초기화
1. 생성자 코드 내부에서 초기화
Circle::Circle() { x = 0; y = 0; }

2. 생성자 서두에 초깃값으로 초기화 (기억하기 힘든 부분!)
Circle::Circle() : x(0), y(0) {}
Circle::Circle(int x) : x(x+100), y(0) {}

3. 선언부에서 직접 초기화 (C++11)

"생성자가 없는 클래스"의 경우, 컴파일러가 '기본 생성자'를 만들어 삽입한다. 기본 생성자는 매개변수 없는 생성자이다.
생성자가 하나라도 있으면 기본 생성자가 만들어지지 않는다.

소멸자 : 객체가 소멸될 때, 소멸자 함수가 자동으로 호출된다. destructor
소멸자 선언은 ~Circle();
소멸자 구현은 Circle::~Circle() {}
소멸자는 클래스에 단 하나만 존재한다. 객체가 사라지기 전에 처리할 작업을 하는 함수이다. (네트워크 연결 끊기, 파일 닫기, 메모리를 운영체제에 반환 등)
* 소멸자는 리턴 타입이 없어야 한다.
* 소멸자는 매개변수가 없으며 클래스에 한개만 존재한다.
* 소멸자가 선언되어 있지 않으면, 기본 소멸자가 자동으로 생성된다. (아무 일도 하지 않고 단순 리턴한다.)

* 객체는 생성된 반대순으로 소멸한다. (스택)

**** 중요!! - 생성자와 소멸자의 실행 순서 ****
지역 객체 : 함수 내 선언 (함수 실행시 생성, 함수 종료시 소멸)
전역 객체 : 함수 외 선언 (프로그램 실행시 생성, 프로그램 종료시 소멸)
* 객체의 실행 순서 역순으로 소멸된다.

접근 지정자
private   : 클래스 내부 멤버만 접근 가능. 외부에서 '절대' 접근 불가능. friend함수는 물론예외!
public    : 클래스 내부 외부 모두 접근 가능.
protected : 클래스 내부 & 현재 클래스를 상속받은 파생클래스에서 접근 가능.

* 접근지정은 같은 것이 여러번 사용 가능 (그러나 굳이..?)
* 접근지정 디폴트는 private
* 생성자를 public으로 선언하지 않으면, 외부에서 생성자를 호출하는 코드가 있을 때 컴파일 오류 발생한다.
  그러나 외부에서 생성자를 호출하지 않으면 굳이 오류가 나지 않는다. 의도적으로 private나 protected로 선언하기도 한다.
  
인라인 함수
함수 호출에 따른 오버헤드로 인해 소모되는 시간이 함수 내부 코드 실행 시간보다 길다면, 루프문과 같은 상황에서 문제가 발생할 수 있다.
따라서 함수 앞에 inline 키워드를 사용해, 인라인 함수로 선언하면 오버헤드로 인한 실행 속도 저하를 막을 수 있다.
이 경우, 함수를 호출하는 대신, 함수의 코드를 그대로 함수 호출부분에 삽입한다.

비교적 작은 크기의 함수에 대해 인라인함수로 선언하여 실행속도를 개선시킬 수 있지만, 그만큼 소스코드의 크기가 늘어난다.
인라인 선언은 강제 명령이 아니므로, 효율을 따져 inline선언을 무시할 수도 있다.
(**재귀, 반복문, static변수, switch문이 포함된 함수는 inline선언이 안되기도 함)

* C++에서는 멤버함수의 크기가 작은 경우, "클래스의 선언부에 함수 내용을 직접 구현 해도 되며,"
  클래스 선언부에 구현된 함수의 경우, 해당 함수는 inline선언이 없어도 인라인 함수로 자동 처리한다.
  
c++ 구조체는, 디폴트가 public인 것을 제외하고, 클래스와 동일한 구조와 기능을 가진다.
다만, c언어와 달리 struct 선언과 동시에 객체 생성은 안된다. (객체 생성시 sturct 키워드를 사용할 수 없다.)

* 헤더파일과 cpp파일은 분리하여 작성, 헤더파일 중복으로 include 시 구현부가 중복으로 들어가면 링크 오류가 발생가능.
* C++ 컴파일러는 cpp파일만 컴파일하며, 헤더파일만 따로 컴파일 하지 않는다.

같은 헤더파일 중복 include 시 문제가 발생한다. (클래스 재정의 문제)
=> 조건 컴파일 문으로 해결한다.
