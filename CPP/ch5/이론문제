1. 4, 묵시에 의한 호출.. this같은 경우는 묵시적으로 인자로 넘기지 않나 싶긴 한데 말이죠..?

2. 1, 값에 의한 호출을 하면, 매개변수에 값을 넘길 때 복사해야함.

3. f(int n[]); 주소에 의한 호출.

4. (1) 같다. (2) 다르다.

5.
(1) 5
(2) 25

6. 1 4 9

7. 2

8. 2

9. 1, 참조 변수는 선언과 동시에 초기화해야한다.

10.
(1) 0 2 4 6 8 10 12 14 16 100
(2) 0 4 6 8 10 12 16 18 18
(3) 0 2 4 6 8 10 12 14 16 18
(4) 0 2 4 6 0 10 12 14 16 18

11. 함수에 매개변수를 전달할 때, 값에 의한 호출로 전달하기 때문이다. 참조에 의한 호출로 전달하면 되므로
void copy(int& dest, int& src) {} 로 선언을 고치면 된다. // 단 주소에 의한 호출은 될 수 없다. 호출문도 수정해야 하기 때문이다.

12. z에 참조 리턴값을 넣어 z로 값을 수정하고자 하면 x, y의 값이 바뀌지 않는다. z에는 매개변수 공간의 참조가 있기 때문에, x,y와는 별도 공간이다.
    w에 참조 리턴값을 넣어 w로 값을 수정하고자 하면 더 큰 y의 값이 100으로 바뀐다.

13. 디폴트 생성자 : MyClass(), 복사 생성자 : MyClass(const MyClass& c);

14. 2, 객체를 값에 의한 호출로 전달하거나, 객체를 return 하거나, 객체 생성과 동시에 대입하는 경우 복사 생성자가 실행되어 복사 생성자가 필요하다.
    하지만 2번처럼 주소에 의한 호출로 전달하거나, 참조에 의한 호출로 전달하거나, 객체를 생성한 이후, 대입하는 경우(치환) 복사 생성자가 실행되지 않는다.
    
15.
(1) 우선 클래스에 ~MyClass(); 코드를 public 영역에 추가한 후 (private 영역에 추가하면 에러가 발생한다.)
    MyClass::~MyClass() { delete [] element; }
(2) MyClass(const MyClass& c) { this->size = c.size; this->element = c.element; }
(3) MyClass(const MyClass& c) { this->size = c.size; this->element = new int[c.size]; for (int i = 0; i < c.size; i++) { this->element[i] = c.element[i]; } }

16. 1, 복사생성자는 중복으로 생성할 수 없다.

17. Student(const Student& c) { name = c.name; id = c.id; grade = c.grade; }

18. Student(const Student& c) { pname = c.pname; pid = c.pid; grade = c.grade; }

**** 중요!! ****
19. 객체의 치환문 a = b; 는 b의 각 멤버를 a의 각 멤버에 1:1로 복사하기 때문에, 두 객체의 element 멤버가 같은 메모리를 가리키게 되어 동적 메모리를 공유하는 문제가 발생한다.
    또한 두 객체중 하나가 소멸한 이후, 나머지 하나가 소멸할 때, 소멸자의 실행 중 문제가 발생한다.
    (객체의 치환문은 얕은 복사와 같다.)
