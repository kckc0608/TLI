1. 1, hwp는 바이너리파일

2. 4, iostream은 헤더파일이므로 텍스트 파일

3. fstream

4. 
(1) 텍스트 IO 방식으로는 바이너리 파일을 읽을 수 없다. \r의 처리 방식이 다르기 때문이다.
(2) 디폴트는 텍스트 IO 이다.
(3) 파일 끝을 알아내는 방법에는 차이가 없다. 모두 EOF로 알아낸다.
(4) '\n'을 입출력하는데 바이너리와 텍스트 IO간 차이가 있다.

5.
(1) 12바이트
(2) 예..?
(3) 11 // 첫번째 줄을 제외한 줄의 수만큼 줄어든다. (마지막줄에 빈줄 개행이 있다면 해당줄은 물론 포함해야한다.)
(4) 12

6.
(1) 19바이트
(2) ^^
(3) 18
(4) 19. 바이너리 모드로 열면 '\n', '\r' 을 모두 읽지만, 텍스트 모드로는 '\r \n' 두개를 읽어서 '\n' 하나만 있는 것처럼 처리하기 때문.

7. ifstream fin("test.txt"); 

8. if(!fout) { cout << "열기 실패"; }

9. 3 // (4) !fin.is_open() 으로 해야한다.

10. 2, 바이너리 모드로는 텍스트파일, 바이너리 파일 모두 열 수 있다. 따라서 해당 파일은 텍스트파일인지 바이너리파일인지 알 수 없다.

11. 
char buf[256];
int n = fin.gcount();
cout.write(buf, n);

12.
char buf[1024];
int n = gcount();
cout.write(buf, n);
n < 1024

13. 파일에 존재하지 않으며, 운영체제가 파일의 끝을 인식하여 입출력 함수가 운영체제 API를 호출하면 알려준다.

14. 3

15. 4, -1 이므로

16. 2, 처음부터 읽어야지.. 파일 열때 EOF도달은 확인하지 않는다.

17. '\r\n'이 연속해서 있는 경우, \r 값을 읽지 않기 때문에 문제가 생길 수 있다.

18. 바이너리 모드로 열었으면 '\r'를 읽을 수 있긴 한데 이게 '\n'하고 같이 있어야 의미가 잇는 것이라, 저렇게 읽으면 '\r' 단독으로만 있는 경우도 카운트 되서 문제

19. 2

20. fin.seekg(99); 또는 fin.seekg(99, ios::beg);

21. 30

22. length - i - 1
