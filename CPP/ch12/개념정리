파일 : 저장매체에 저장되는 정보, 바이트/블록 단위로 입출력
텍스트파일 : 글자/문자만으로 구성된 문서 파일. 문자 코드(아스키/유니코드)가 아닌 어떤 값도 존재할 수 없음.
바이너리파일 : 문자코드 이외의 값이 들어있는 파일. 사진, 오디오, 이미지, 컴파일된 코드(목적코드) 등등.

"중요"
텍스트 편집기들은 사용자가 입력한 엔터키를 '\r'과 '\n' 두 아스키코드로 저장한다.
\r은 캐리지리턴, 커서를 현재 줄의 맨 앞으로 옮기도록 하는 지시어.
\n은 커서를 현재 있는 위치에서 한줄 밑으로 옮기도록 하는 지시어.
따라서 다음 줄의 맨 앞으로 가기 위해 \r, \n 두개가 필요하다.

파일 입출력 스트림, std 이름공간에서 쓰임.
ifstream : 파일 읽기 (파일 -> 프로그램 으로 데이터 전송)
ofstream : 파일 쓰기 (프로그램 -> 파일 으로 데이터 전송)
fstream : 파일 읽기, 쓰기 동시에

위 클래스들도 basic_ifstream, basic_ofstream, basic_iofstream 템플릿에 char 타입으로 구체화한 클래스를 typedef 한 것들이다.

위 스트림들은 '파일-프로그램'을 연결한다.
위 스트림들을 쓰기 위해서는 <fstream> 헤더파일을 추가해야 한다.

* 파일 입출력 모드
텍스트모드 : 파일의 바이트를 문자로만 해석하는 입출력방식. 텍스트 파일의 읽고 쓰기에 사용
바이너리모드 : 모든 파일을 단순히 바이트의 스트림으로 다루기 때문에, 파일의 종류에 상관없이 읽고 쓰기 가능.

** 파일 쓰기 객체 생성
ofstream fout; // 파일 출력 스트림 객체 생성
fout.open("a.txt"); // 파일명을 매개변수로 하는 open() 멤버함수 호출. => 파일을 열어 스트림에 연결.

만약 파일이 읽기전용이거나, 디스크 용량이 모자라 파일을 새로 만들 수 없는 경우 파일 열기는 실패한다.
또 open함수 없이 ofstream fout("a.txt"); 와 같이 생성자에서 매개변수를 전달해 바로 파일을 연결할 수 있다.

파일 열기 성공이 실패한 경우 스트림에 파일이 연결되어 있지 않아 파일에 쓰기를 할 수 없다.
이를 검사하기 위해 ! 연산자를 사용한다. (재정의 되어있음)
if (!fout) { 열기 실패시 처리할 코드 }

파일 열기가 실패하면 true, 성공하면 false 리턴한다. is_open() 함수로 검사할 수도 있다.

if (!is_open()) { 파일 열기 실패시 처리할 코드 } // 이 경우 !는 재정의 된 것이 아니다.

이제 파일 쓰기를 '<<' 연산자로 할 수 있다. cout과 똑같다.

fout << "hihi" << endl;
fout << age << endl; // age = 21
fout << name << endl; // name = "mike"

파일 쓰기를 마치고, close() 멤버함수를 호출해 스트림과 파일의 연결을 끊을 수 있다. 버퍼에 남아있는 데이터를 파일에 마저 쓰는 기능도 수행한다.

fout.close();

** 파일 읽기
파일 쓰기와 똑같다.

ifstream fin("a.txt"); // 파일 열기 & 스트림 연결. 존재하지 않는 파일이면 오류 발생
if (!fin) { 파일 열기 실패시 처리 코드 }
int a;
fin >> a;
fin.close();

파일에 상대경로를 쓸 경우에는 상관없지만, 절대경로를 쓸 경우, \를 \\로 두번 써야한다. \ 를 한번만 쓰면 이스케이프 시퀸스로 처리하기 때문.

** 파일 모드
파일을 열때, 어떤 파일을, 어떤 방식으로 입출력할지 정한다.
ios::in // 읽기 모드 오픈
ios::out // 쓰기 모드 오픈
ios::ate // 파일 끝으로 파일포인터를 이동한 상태로 파일 쓰기모드 오픈 (하지만 좀 다르다)
ios::app // 파일을 쓸 때마다 파일 포인터를 끝으로 이동시켜서 파일 쓰기. (초기에는 파일 포인터가 파일 처음)
ios::trunc // 파일이 존재하면 파일을 열 때, 내용을 모두 지우고 오픈. ios::out 모드로 지정할 때 디폴트로 지정된다.
ios::binary // 바이너리 모드로 읽고 쓰기. 디폴트는 텍스트 모드이다.

착각하기 쉬운데, ios::in 을 ifstream, ios::out 을 ofstream 에서만 써야하는 건 아니다. 마음대로 써도 된다.

그리고 책에서 설명을 틀리게 해놨는데, ios::ate는 파일 포인터를 끝으로 옮기는 기능만 하는 것 같다. 파일 쓰기모드로 오픈따위 하지 않는다.

fstream fout("a.txt", ios::ate); 이렇게 하면 파일 쓰기가 될까? 안된다.
fstream fout("a.txt", ios::out | ios::ate); 이렇게 해야 파일 쓰기가 된다. 그리고 놀라운 점은 ios::out 이 지정되면서 파일 내용을 날려버린다.
그래서 파일 내용이 날아가 버리기 때문에 굳이 파일포인터를 맨 뒤로 넣은 의미가 없다. 기존 파일을 불러와서 임의 위치의 내용을 수정하려면 이렇게 할 수 없다.
그래서 해결책은 놀랍게도 ios::in 을 같이 쓰는 것이다. 그렇게 하면 파일 초기화가 안된다. (ios::in | ios::out | ios::ate)
ofstream은 기본적으로 ios::out을 설정하기 때문에 굳이 명시적으로 설정할 필요는 없다.

개인적으로 이해가 안되는 부분인데, 어차피 파일 내용 중간에 임의로 쓰기는 ios::out 만으로도 충분히 된다.
그렇다면 ios::ate을 대체 왜 만든건지 이해가 안된다. 파일 포인터 맨 뒤로 두는 코드 한줄 더 쓰는게 귀찮아서?
ios::app가 파일을 쓸 때마다 파일 맨 끝에서부터 쓰도록 강제 고정시켰으니, 이와 다르게 임의 위치에 쓰는걸 목적으로 두고 만들었어야 한다고 생각하는데,
그러면 임의위치에 쓰는걸 목적으로 할 경우, ios::app 처럼 파일 오픈시 내용을 날러버리는 기능은 없앴어야 했다. 
근데 그걸 왜 설정을 안해놔서 코드를 이해하기 어렵게 ios::in을 같이 쓰도록 만드는지 도저히 이해가 안된다.

파일 모드 설정은 open() 함수에 파일 경로명 다음 인자로 넣거나 애초에 생성자에서 파일 경로명 다음 인자로 넣을 수 있다.
ifstream은 기본적으로 ios::in 을 지정하고
ofstream은 기본적으로 ios::out 을 지정한다.

** 멤버함수를 이용한 텍스트 파일 읽고 쓰기
텍스트 읽고 쓰기를 위한 함수로 put(), get() 이 두가지가 있다.
원형은 다음과 같다.

  int get();
  ostream& put(char ch);

중요한점은 int get() 함수는 텍스트 IO 모드에서 \r\n 이 두 바이트에서 \r 을 무시하고 \n 하나의 바이트만 리턴한다.
따라서 get() 함수가 호출된 횟수는 실제 바이트 개수와 차이가 난다.

** get()이 파일의 끝을 인식하는 과정
get() 함수는 파일에서 한바이트를 읽어들인 후, 파일 포인터를 다음 위치로 전진시킨다.
이때 파일의 마지막 내용을 읽었다면 파일 포인터가 전진하여 EOF를 가리키는데, 이 상태에서도 아직까진 EOF 상태로 인식되지 않는다.
( eof() 함수를 호출해도 false 리턴 )
이 상태에서 한번더 get() 함수가 호출되면 -1 로 EOF를 리턴하면서, 스트림 객체 내부의 eofbit를 1로 세팅한다.
그러면 이제 eof() 함수로 true 값을 리턴받을 수 있게 된다.

따라서 
while(!fin.eof()) {
  char c = (char) fin.get();
}

이렇게 파일을 읽으면 안된다. fin.get()이 -1을 리턴하고 나서 eof()가 true를 반환하기 때문에, 맨 마지막 char c 에는 -1에 해당하는 char 이 들어간다.
이 경우 의도치 않은 상황이 발생한다.

따라서 반드시 fin.get() 함수 호출을 하고나서 fin.eof() 함수 호출을 해야 eof 체크가 된다.

** 라인단위 파일 읽기

1. ifstream fin; fin.getline(char* line, int n); // line 만큼에서 n만큼 읽음. // n-1만큼 읽어서 line 배열에 넣고 마지막에 '\0' 추가.

  while ( fin.getline(buf, 81) ) { ... } // 한 라인이 최대 80개의 문자로 구성. buf에 담아서 buf배열로 읽은 라인 처리
  이 경우, fin.getline() 이 fin 을 다시 리턴하여 결국 while (fin) 이 실행된다. 이는 operator bool () 연산자를 실행하여
  현재 스트림 내부의 오류 상태를 검사하고, 오류상태이면 false 를 리턴한다. 그래서 더이상 읽을 데이터가 없다면 오류가 발생하여 false 를 리턴한다.

2. getline(fin, string& str); 이용, 읽어서 str에 할당.

  얘도 마찬가지로 fin을 리턴함. 즉 bool () 연산자가 실행된다.
  
** 바이너리 파일 읽고 쓰기
간단하다. fstream fbout("a.txt", ios::out|ios::binary); 이렇게 바이너리 플래그만 설정하면 된다.
바이너리도 get, put 함수를 이용해서 읽고 쓴다.

** 블록단위 파일 읽고 쓰기 (read(), write())
read() : istream의 멤버함수. ifstream이 상속받는다.
write() : ostream의 멤버함수. ofstream이 상속받는다.

istream& read(char* s, int n) // 최대 n개의 데이터를 읽어 s배열에 저장한다. 파일 끝을 만나면 읽기 중단.
ostream& write(char* s, int n) // 배열 s의 처음 n개의 바이트를 파일에 저장.
int gcount() // 최근 파일에서 읽은 실제 바이트 수 리턴 => read 함수가 모든 n개의 바이트를 읽었다고 단정할 수없기 때문에 활용.

이렇게 블록단위로 읽으면 당연히 실행속도가 더 빠르다.

** 변수 / 배열 자체를 통으로 읽고 쓰기
메모리주소를 바이너리로 읽고 써버린다.
ofstream fout("test.dat", ios::binary);
int n [] = { 0, 1, 2, 3, 4, 5 };
double d = 3.14;
fout.write((char*)n, sizeof(n)); // n의 주소를 강제로 char* 타입으로 변환시켜버린 후, n의 사이즈만큼의 메모리 내용을 통으로 바이너리 쓰기.
fout.wirte((char*)&d, sizeof(d)); // d의 주소를 강제로 char* 타입으로 변환시켜버린 후, d의 사이즈 만큼의 메모리 내용을 통으로 바이너리 쓰기.

읽을 때는 다음과 같이 읽는다.
fin.read((char*)n, sizeof(n)); // n의 주소를 강제로 cahr* 타입으로 변환시켜 여기에 n의 사이즈 만큼 읽어들여버린다.
fin.read((char*)&d, sizeof(d));/ // d 의 주소를 강제로 cahr* 타입으로 변환해서 여기에 d의 사이즈만큼을 읽어들여버린다.

int 타입의 정수는 4바이트이므로 4바이트씩 읽는다.

** 바이너리 IO과 텍스트 IO의 차이점
딱 하나다. \r 을 읽냐 안읽냐
텍스트는 \r\n을 읽어서 \n으로 받아들이고, \n을 쓰면 \r, \n 두개로 내보낸다.

단 >>, << 연산자는 무조건 텍스트 IO로만 작용할 뿐만 아니라 \n 자체를 읽지 않는다.

** 스트림 상태 검사
eofbit = eof에 도달한 상태로 읽기를 시도하면 활성화
failbit = 포맷 오류나 쓰기 금지된 곳에 쓰기를 시도하는 등, I/O 실패시에 1로 세팅 (없는 파일을 연다거나)
badbit = 스트림이나 데이터가 손상되는 수준의 진단되지 않는 문제가 발생한 경우, 유효하지 않은 입출력 명령이 주어졌을 때 1로 세팅

eof()
fail()
bad()
good() // 모두 정상적이면 true
clear() // 모두 0으로 초기화

** 파일 포인터
파일입출력은 기본적으로 순차접근. 하지만 파일포인터를 사용해 임의접근도 가능하다.
파일포인터는 다음 2개가 있다.
get pointer -> get, read, getline, >> 연산은 이 포인터가 가리키는 지점에서 읽음.
put pointer -> put, write, << 연산은 이 포인터가 가리키는 지점에서 씀.

ate : put pointer를 파일 끝(EOF)으로 이동시킨 채로 오픈
app : put pointer가 파일 시작점에 있는 채로 오픈되지만, 쓸때마다 파일 끝으로 이동.

임의 포인터 이동
istream& seekg(streampos pos) // 사실 정수값을 넣어서 절대 위치로 이동 (시작점은 0)
istream& seekg(streamoff offset, ios::seekdir seekbase) // 상대적인 위치를 기준으로 이동.
streampos tellg() // 현재 get pointer 위치 반환

ostream& seekp(streampos pos) // 사실 정수값을 넣어서 절대 위치로 이동 (시작점은 0)
ostream& seekp(streamoff offset, ios::seekdir seekbase) // 상대적인 위치를 기준으로 이동.
streampos tellp() // 현재 put pointer 위치 반환

상대적 위치 기준 상수 : ios::beg, ios::cur, ios::end

ios::end 는 파일 끝의 다음 EOF를 가리키므로, ios::end가 가리키는 지점의 포인터 값을 읽으면 그게 곧 파일 사이즈이다.
