1. 3, 표준 입출력 스트림이 GUI를 지원한다는 말은 들어본 적이 없다. // 4. 맞는 말이다. 2003년 이후 다국어 지원을 위해 제네릭 클래스로 작성한 후 구체화하여 작성하였다고 한다.

2. 4, cout.flush() 다. 이런 말장난은 좀 너무한듯..

3. 키보드

4. 스크린

5. cin, cout, clog, cerr // iostream 헤더를 추가하면 자동으로 생성되는 모양이다..?

6. 2, istream은 구체화된 클래스이다.

7. 1

8. char 타입으로 구체화한 클래스

9. abc, put() 함수가 cout 객체의 참조를 리턴하므로 이어서 쓸 수 있다.

10. 변수에 '\n'을 저장하지 않는 것은 공통점이지만, get() 함수는 버퍼에 '\n'를 남기고, getline() 함수는 버퍼에 '\n'을 남기지 않는다.

11. 1, cin은 >> 연산자로 공백이 들어간 문자열을 입력받을 수 없다.

12. 15, get() 함수는 '\n'을 버퍼에 남겨둔다 (읽지 않는다.) getline() 함수는 '\n'까지 포함해서 읽는다. 따라서 gcount()에는 포함된다. 하지만 배열에는 저장되지 않는다.

13. 
(1) 읽을 수 없다. cin의 >> 연산자는 개행문자를 포함한 공백문자를 저장하지 않고 문자열 구분 기준으로 삼는다.
(2) 읽을 수 있다. cin.get()은 문자 하나하나를 읽는다. 물론 '\n'도 포함.
(3) 읽을 수 있다. cin.get(ch)도 문자를 하나하나 읽어 ch에 저장한다.
(4) 읽을 수 없다. cin.get(buf, 10); 은 공백문자를 애초에 버퍼로 읽어오지도 않으며, 설사 cin.getline()을 썼대도 버퍼에서 읽기만 할 뿐, 배열에는 저장하지 않는다.

14. 4, flush() 는 cout객체의 멤버함수로, 버퍼를 비우는 함수이지 포맷팅 관련 함수가 아니다.

15. 4, put은 cout 객체의 멤버함수로, 조작자는 아니다.

16. %%%%%%%%%C++

17. 일단 2./3 을 실행한 결과는 0.6666666666666 인데, precision(4)에 의해 유효숫자 4개로 바뀐다. 그러면 0.6667이 된다.
    0.6667을 표현하는데에 6개의 칸을 사용했다. 따라서 width(10)에서 6을 뺀 4개의 공백이 남고, left 정렬로 세팅 했으므로 결과는 다음과 같다.
    
    0.6667~~~~

18. 매개변수를 가진 조작자를 쓰기 위해 <iomanip> 헤더가 필요하다.

19. ostream 헤더에 선언되어 있다. 원형은 다음과 같다. ostream& operator << (char ch) // 헤더에 존재하는 클래스의 멤버함수로 덮어씌워져있으므로, 매개변수가 ostream& outs, char ch 가
    아니다. 사용자 정의 연산자와 헷갈리지 말기
    
20. 4, 조작자는 표준C++ 헤더파일에 정의된 함수이다.

21. cin 객체와 함께 사용되고 있다. '있다면' -> 사용자 정의 조작자. 이걸 호출할 것이다. istream& operator >> (istream& (* _f) (istream& ins) )
    따라서 istream& ignoredigit (istream& ins) 이게 원형일 것이다.
    
22. ostream& ten (ostream& outs)
