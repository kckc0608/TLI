* 스트림
연속적인 데이터 흐름 / 데이터를 전송하는 소프트웨어 모듈.

1. 입력스트림 - "키보드, 네트워크, 파일 등 입력장치" => "프로그램" 데이터 전송 (표준 입력스트림 객체 - cin)
2. 출력스트림 - "프로그램" => "프린터, 하드디스크, 스크린, 네트워크, 파일" 데이터 전송 (표준 출력스트림 객체 - cout)

* C++은 스트림이 '버퍼'를 가진다. 데이터를 받자마자 바로 전송하는게 아니라, 버퍼에 모아뒀다가 한번에 전송한다.
* 키 입력 스트림 버퍼 : 키보드와 연결되어 키보드 입력을 임시로 저장하는 cin객체의 버퍼. enter 키를 누르면, 버퍼의 내용을 프로그램에 전달한다.
* 스크린 출력 스트림 버퍼 : 스크린과 연결되어, 프로그램 출력을 임시로 저장하는 cout 객체의 버퍼
  버퍼에 '\n'가 오거나, 버퍼가 꽉 차거나 cout.flush(); 명령이 들어올 때, 버퍼의 내용을 스크린으로 출력한다.

데이터 입출력은 운영체제 API를 통해 이루어지는데, 버퍼의 사용은 운영체제 API의 호출 횟수를 줄여, 시스템 효율을 높이고, 입력 중, 입력 내용의 수정을 가능하게 한다.

C++ 표준은 버퍼를 사용하는 '스트림 입출력만 지원' 한다.
또 다른 입력방식으로는 '저수준 입출력 방식' 이 있는데, 이는 키를 누름과 동시에 프로그램에 전달되는 방식으로, 게임을 만들 때 주로 사용한다.

2003년 이후, 다국어 언어의 입출력 지원을 위해 스트림 객체를 수정했다. 기존 char 사이즈로는 2바이트 문자를 저장할 수 없었는데,
이 문제가 cin에는 그대로 남아있어 cin으로는 문자단위로 한글을 읽을 수 없다.

ios : 입출력 스트림 클래스의 기본 클래스, 공통변수 / 상수 / 멤버변수 선언
iostream / istream / ostream : 문자 단위 입출력 스트림
ifstream / ofstream / fstream : 파일 입출력 스트림

cin : 키보드와 연결된 istream 타입의 '표준 입력 스트림 객체'
cout : 스크린 장치와 연결된 ostream 타입의 '표준 출력 스트림 객체'
clog cerr : 표준 오류 출력 스트림 객체, cerr는 버퍼를 거치지 않고 스크린에 오류를 출력하는 차이점이 있다.

*** 중요 ***
ostream 객체의 멤버함수로 문자 출력하기
1. cout.put(char ch); -> 한 문자 단위로 출력, 정수값을 넣으면 아스키코드 값으로 보아 출력
2. cout.write(char* str, int n); -> str 에 들어있는 문자들을 앞에서부터 n개 출력
3. cout.flush(); -> 출력 버퍼에 있는 모든 문자를 강제 출력

* 컴파일러에 따라 put(), write() 함수가 호출되어 문자를 버퍼에 기록한 이후, 알아서 바로 버퍼를 출력하기도 하기 때문에,
flush() 함수가 필요없는 경우도 있다.

istream 객체의 멤버함수로 문자 입력받기
기본적으로 cin은 공백문자를 입력할 수 없다. 하지만 아래 함수들은 공백도 입력받는다. (한글은 2바이트로 입력받을 수 없다.)
1. int get() -> 문자를 하나 읽어와 return 한다. 만약 입력스트림의 끝을 만나면 EOF를 리턴한다. EOF는 -1 정수값이기에 문자를 반환함에도 int형으로 반환한다.
                '\n'도 읽어들인다.
2. istream& get(char& ch) -> 입력스트림에서 문자를 읽어 ch에 저장하고, 스트림을 리턴한다. 역시 공백문자도 읽을 수 있다.
                             만약 eof를 만나면, cin 스트림 내부에 "eofbit" 플래그를 세팅하므로, cin.eof() 함수로 플래그 세팅여부를 알 수 있다.

3. istream& get(char* s, int n); -> 입력스트림에서 n-1개의 문자를 읽어 s에 저장하고, 마지막에 널문자 삽입. 중간에 '\n'를 만나면, '\0'을 삽입하고 리턴.
                                    중간에 EOF를 만나거나 오류가 발생하면 배열에 '\0'을 넣고 리턴한다.
                                    char str[10];
                                    get(str, 10); // 배열의 크기가 10인 char 배열에 문자열 입력, 9개까지 입력가능.

** 주의 **
get 으로 문자열을 입력받는 경우, '\n'을 만나면 읽기를 중단하고 리턴하기 때문에, 버퍼에 '\n'가 남아있다. 따라서 이 상태에서 다시 읽기를 시도하면
'\n'을 읽어들여 아무것도 읽지 않고 바로 리턴한다. 프로그램이 무한루프에 빠질 수도 있다.

따라서 버퍼에서 '\n' 을 제거하기 위해서는 다음과 같이 한다.

  cin.get();
  cin.ignore(1); // 버퍼에서 문자 1개 삭제

무한루프에 빠지는 과정은 간단하다. 
버퍼에서 '\n'을 만남 -> '\n'을 만나면 읽기를 중단하고 리턴 -> 버퍼에는 '\n' 이 남아있음 -> 버퍼에서 '\n'을 만남 -> .....

또한 다음코드는 놀랍게도 작동을 한다..

    char cmd[1];
    while (true) {
        cout << "종료하려면 exit 입력 >>";

        cin.get(cmd, 80);
        if (strcmp(cmd, "exit") == 0) {
            cout << "exit...";
            return;
        }
        else {
            cout << cmd << endl;
            cin.ignore(1);
        }       
    }
    
    놀랍게도 이 코드는 문제가 발생하지 않는다. 심지어 길이가 1보다 큰 문자열을 넣어도 다 넣어진다!!
    
    char cmd[1];
    while (true) {
        cout << "종료하려면 exit 입력 >>";

        cin.get(cmd, 80);
        if (strcmp(cmd, "exit") == 0) {
            cout << "exit...";
            return;
        }
        else {
            cout << cmd << endl;
            cout << cmd[0];
            cout << cmd[1];
            cout << cmd[2];
            cin.ignore(1);
        }       
    }

    이 코드도 놀랍게 작동한다...
    cmd배열의 크기를 넘는 인덱스를 참조했는데 작동을 하신다.... (참조도 잘 된다.)
    
    내 예상으로는 cmd라는 배열의 첫 주소를 받고, 해당 주소를 시작점으로 char 크기만큼 이동하면서 메모리에 값을 저장하는게 아닐까 싶다.
    이게 맞다면 배열에 의해 선점된 메모리가 아니라는 점에서 좀 위험한 접근이긴 함.
    
    만약 eixt보다 작은 크기의 배열이라면 cout << "exit..."; 코드가 실행되고나서 런타임 오류가 발생하는데,
    Stack around the variable 'cmd' was corrupted 라는 오류가 발생한다.
    
cin.get()으로는 한글을 읽을 수 없기 때문에, 한글 문자열 길이의 2배 + 1 인 char 배열을 이용해서 한글을 저장해야 한다.
책에는 문자열 길이의 2배로 길이를 설정하라고 하는데, 그렇게 하면 당연히 오류난다. 널문자를 넣을 공간이 없기 때문.

    char cmd[4];
    while (true) {
        cout << "종료하려면 exit 입력 >>";

        cin.get(cmd, 80);
        if (strcmp(cmd, "종료") == 0) {
            cout << "exit...";
            return;
        }
        else {
            cout << cmd << endl;
            cin.ignore(1);
        }       
    }
    
    이건 런타임 오류발생.
    
    char cmd[5];
    while (true) {
        cout << "종료하려면 exit 입력 >>";

        cin.get(cmd, 80);
        if (strcmp(cmd, "종료") == 0) {
            cout << "exit...";
            return;
        }
        else {
            cout << cmd << endl;
            cin.ignore(1);
        }       
    }
    
    이게 정상 작동.
    
* 한줄 읽기
책에는 istream& get(char* s, int n, char delim='\n') 가 소개되어 있다.
근데 이건 디폴트 매개변수를 사용하는 경우 문제가 발생하는 모호한 함수 중복아닌가?
get(char* s, int n) 과 get(char* s, int n, char delim='\n') 을 어떻게 구분하는지 알 길이 없다...
(하지만 비주얼스튜디오로 cin.get()의 원형 목록을 보면 저 두가지가 나눠져서 들어가있다... 이해가 전혀 안되는 부분이다.)

또는

istream& getline(char* s, int n, char delim='\n')

비슷하다. 하지만 차이점이 있다. getline은 버퍼에서 delim 문자를 제거하지만, get()은 제거하지 않는다.
따라서 한줄 읽기를 하고나서 get()은 cin.ignore()을 통해 버퍼에서 문자를 제거해야 한다. 
하지만 또 의문점...

    char cmd[10];
    while (true) {
        cout << "종료하려면 exit 입력 >>";
        cin.get(cmd, 10, '!');
        if (strcmp(cmd, "eixt") == 0) {
            cout << "exit...";
            return;
        }
        else {
            cout << cmd << endl;
            cin.ignore(1);
        }       
    }
    
    !가 delim 문자 이므로, 변수에 !를 저장하지 않고, '버퍼에는 남겨둘 것'이다.
    그렇다면 ignore(1)을 했으니, 버퍼에 남겨진 !를 지우고 나면 버퍼에 '\n' 이것이 남아 있을 것이다.
    그럼 무한루프가 발생해야하지 않을까?
    
    놀랍게도 무한루프 발생도 없고, hihi만 잘 읽는다. '!'는 버퍼에서 빠진 것일까?
    
    char cmd[10];
    while (true) {
        cout << "종료하려면 exit 입력 >>";
        cin.get(cmd, 10, '!');
        if (strcmp(cmd, "eixt") == 0) {
            cout << "exit...";
            return;
        }
        else {
            cout << cmd << endl;
            cout << char(cin.get()) << endl;
            cin.ignore();
        }  
        
     아니 버퍼에 남아있다!! 이 코드의 실행결과는 
     hihi
     !
     이기 때문이다.
     
     그럼 여기에서 저 ignore()를 빼면 어떻게 될까?
     무한루프가 놀랍게도 안돈다!! 즉 '\n'가 버퍼에 없다는 이야기...? delim문자를 만나면 그 문자를 버퍼에 남겨두는 건 맞는데, '\n'를 버퍼에 남기지는 않는 것 같다.
     특이하다....

getline() 은 변수에 저장도 안하고 버퍼에도 안남긴다고 하니까 테스트를 해보면
실행 결과가 다음과 같다.
    hihi
    
그냥 공백이 나온다. 당연히 EOF겠거니 했는데

    cout << cmd << endl;
    cout << (cin.get() == EOF) << endl;
    
    이 코드의 실행결과는 아래와 같다.
    
    종료하려면 exit 입력 >>hihi!
    hihi
    0

얼라리.. EOF는 또 아니라고..? EOF 플래그도 세팅이 안되어 있었다.
뭐가 뭔지 모르겠다. 출력해보니 아스키코드값 10이 출력된다. 찾아보니 LF라는 공백문자다.

ignore 함수의 원형은 다음과 같다.
isteram& ignore(int n=1, int delim = EOF); // 인자 없이 넣으면 EOF를 만날 때까지 그냥 모든 문자를 버퍼에서 빼버린다.
delim 문자를 만나면 "해당 문자를 제거하고" 종료한다.

gcount() 함수는 최근에 읽은 문자의 개수를 리턴한다. 이때 엔터키도 개수에 포함하는데, 그냥 delim 문자도 포함하는 걸로 보면 될 것 같다.

이때 get함수는 버퍼에 delim문자를 남겨두므로 gcount를 사용하면 정말 문자 개수만 읽는다.

*** 포맷 입출력 방법 ***
1. 포맷 플래그 - ios 클래스에 상수로 선언되어 있다. setf() 함수로 설정하고, unsetf() 함수로 해제한다. 한번 설정하면 해제할때까지 유지된다.
                 | 비트 or 연산자로 여러플래그를 동시에 설정할 수 있다.

2. 포맷 함수 - ostream 클래스에 width(), fill(), precision() 은 출력 필드의 너비, 빈칸채우는 문자 지정, 유효숫자 개수를 지정하는데 사용된다.
               이 포맷은 << 연산자를 이용하여 출력될 때만 적용되며, "" 1회성 "" 이다.
               
        cout.width(10);
        cout << "hello" << endl;;
        cout << "hihi";
        
        hello 에만 10 너비 적용됨.
        
        cout << "hello" << endl << "hihi"; 
        
        이렇게 해도 마찬가지, 호출 직후 1개의 필드에만 적용된다.
        fill()은 width로 지정된 너비를 보다 작은 문자열이 있을 때, "" 디폴트로 오른쪽 정렬 후 "" 왼쪾 공간에 해당 문자로 채운다.
        
        precision() 은 유효 숫자 자리수를 "디폴트로 6" 인 값을 임의로 조정하여 변경할 수 있다.
        precision(5); // cout << 1/3 = 0.33333, 디폴트는 0.333333

3. 조작자 - 함수다. 매개변수 없는 조작자와 매개변수를 1개 같은 조작자로 나뉘며, 언제나 <<. >> 연산자와 사용된다.
            매개변수 없는 조작자는 <iostream>을 사용한다.
            매개변수를 1개 갖는 조작자는 <iomanip> 헤더를 사용한다.
            setw() // set width
            setfill()
            setprecision() 등이 있다.
            
            조작자 역시 한번의 입출력(필드 하나) 에만 사용된다.

** 삽입 연산자의 중복 (스트림에 삽입하는 연산자)
우리가 직접 iostream 클래스에 연산자를 중복시킬 수 없으니, 전역 함수로 만들고 사용자 지정 클래스에 프렌드로 넣어줘야한다.

Point p(3,4);
cout << p;

이걸 한다고 한다면, 컴파일러는 저걸 << (cout, p); 이렇게 바꿀 것이다. 즉 좌측에는 ostream 객체의 참조를, 우측에는 출력할 객체를 담으면 되고,
return 타입은 ostream 객체의 참조를 리턴하여 인자로 받은 객체를 그대로 리턴하면 된다. 매개변수로 들어온 ostream의 이름을 가지고 cout 쓰듯 쓰면 된다.

** 추추 연산자의 중복 (스트림에서 추출해오는 연산자)
똑같다. ostream을 istream으로 고치면 그만. 이때 추출 연산자의 인자로 들어오는 사용자 지정 객체는 "참조"로 받아야 함에 주의해야한다.
입력받은 값을 객체에 넣으려면 복사본에 넣지 말고, 원본 그대로에 넣어야 하니까.

**** 중요!! **** 
* 사용자 조작자 정의하기

cout << endl; 이거를 컴파일러는 cout.<<(endl); 이렇게 바꿀텐데, 어떻게 함수를 매개변수로 넘길 수 있을까?

ostream& ostream::operator << (ostream& (* _f)(ostream&) ) {
    (* _f)(*this); // * _f 함수에 출력 스트림 객체를 인자로 주어 해당 함수 실행.
    return *this;  // 출력 스트림 객체 참조 리턴
}

임의 함수를 정의하는 것이 " 리턴형 (* _f) (매개변수 자료형) " 인 것 같다.

따라서 매개변수 없는 함수의 원형은 다 저렇게 생겼다.
ostream& 함수명 (osteram& outs)
istream& 함수명 (istream& ins)

그래서 저런 원형을 가진 함수를 만들어 구체화하고, cout << 함수명; 이렇게 호출하면 된다.
