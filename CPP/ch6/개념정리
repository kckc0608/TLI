함수 중복 : 이름이 같으나, 매개변수 타입이나 개수가 다른 함수. "" 리턴 타입은 고려대상이 아니다!!!"", 리턴타입만 다르면 어떤 함수를 호출해야할지 모호하기 때문.

* 함수 중복은 컴파일 시에 이루어지므로, 실행시간에 영향은 없다.

* 생성자 함수도 중복 작성이 가능하다.

**** 소멸자는 함수 중복이 불가능하다!! ****
* 복사 생성자는 생성자 중복 함수로 볼 수 있으니 별개겠지만, 복사 생성자는 1개만 존재.

디폴트 매개변수 : 매개변수 = 디폴트 값 형태로 선언되며, 오른쪽부터 왼쪽 순서대로 선언해야 함.
디폴트 값의 전달은 컴파일러에 의해 처리된다.

** 포인터는 디폴트 매개변수 값이 있을 수 있지만, 참조는 디폴트 매개변수를 쓸 수 없다.

* 디폴트 매개변수를 활용하여, 함수 중복을 간소화 할 수 있다.

**** 디폴트 매개변수를 가진 함수는, 같은 이름의 중복함수들과 선언될 수 없다. ****
예를 들어
f()           // ok
f(int r)      // ok
f(int r = 1)  // nope

만약 아무런 값을 주지 않고 f()를 호출하면 f() 인지 f(1) 인지 모호하므로!

***** 함수 중복의 모호성!!! *****
1. 형 변환으로 인한 모호성
원래 매개변수에 전달된 값의 타입과, 매개변수 타입이 다르면 형변환을 시도한다.
자동적으로 작은 타입을 큰 타입으로 자동 형 변환한다. char -> int -> long -> float -> double
즉 char는 오른쪽의 어떤 것으로도 형변환이 가능하지만, double은 어떤 것으로도 형변환 될 수 없다.

하지만 float f(float a); double f(double a); 가 있을 때, f(1)을 호출하면 어떤 것으로 형 변환해야할까?
int는 float, double 모두 형 변환이 가능하므로 모호하다. 따라서 컴파일 오류가 발생한다. (형변환 역시 컴파일 타임에 결정)
(만약 1.0 을 전달하면 double이 호출된다.)

2. 참조 매개변수로 인한 모호성
f(int a);
f(int& a);
이렇게 두개가 있을 때, f(n)을 넘긴다면 어떤 것을 호출해야할까?
모호하므로 컴파일 오류 발생

3. 디폴트 매개변수로 인한 모호성
f(int a);
f(int a, int b = 10);
이렇게 두개가 있을 때, f(10)을 호출하면 어떤 함수가 호출되어야 할까?
모호하므로 컴파일 오류 발생

** 또한 배열 이름은 포인터이므로 f(int [] a) 와 f(int * a) 는 공존할 수 없다.

static : static은 변수의 생명주기와 사용 범위를 지정하는 방식중 하나. 프로그램이 시작될 때 생성, 종료될 때 소멸, 변수나 함수가 선언된 범위내에서 사용.
클래스 안에서 static변수를 사용하면 해당 변수는, 클래스로부터 생성된 모든 객체가 공유한다.
static int a = 10; 이런 식으로 선언

*** static 멤버는 클래스 외부에 전역 변수로 선언되어야 한다.
int Person::sharedMoney = 100; 이런 식으로 선언되어야 한다.
static 멤버는 객체 내부가 아닌 별도 공간에 생성되어 클래스 멤버라고도 부른다.
프로그램과 생명을 같이하므로, 객체가 만들어 지기전에 이미 존재하고, 객체가 사라져도 존재한다.

static멤버는 클래스명::static변수명 으로 접근해서 사용할 수 있다.

static은 전역 변수나 전역 함수를 클래스에 캡슐화하는 역할을 한다. 따라서 객체사이에 공유하는 멤버가 된다.
static 멤버 함수는 오직 static 멤버에만 접근할 수 있다. static 멤버 함수는 객체 생성전에도 존재할 수 있고, 호출할 수 있기 때문이다.
(이를 안지키면 컴파일 오류)

static 멤버 함수는 this를 사용할 수 없다. 객체가 만들어지기전에 호출 될 수 있으므로, this 연산자가 가리킬 객체를 얻을 수 없을 수도 있기 때문이다.
