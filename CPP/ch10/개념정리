함수중복 -> 데이터 타입만 다른 동일한 형태의 함수에 대해 코드 중복 발생 => 데이터타입을 일반화 시킨 "템플릿 함수"로 문제 해결

템플릿 = '형판', 말 그대로 찍어내는 틀.

템플릿함수 = 제네릭함수 = 데이터타입이 일반화된 함수

제네릭 함수 선언
template <class T> mySwap(T t1, T t2) { ... }

<class T> 또는 <typename T> 로 제네릭 타입을 선언한다. (반드시 제네릭타입 이름이 T일 필요는 없다.)

구체화 = 함수들을 템플릿화 하는 과정의 역과정, 말 그대로 템플릿으로부터 구체적인 타입을 지닌 함수를 찍어내는 것.
mySwap(1, 2) 로 함수를 호출하면, T라는 제네릭타입을 int로 일반화한 것이다.
하지만 제네릭 타입 하나는 동시에 한가지 타입으로밖에 구체화 되지 않는다.
따라서 mySwap(1, 0.5) 이렇게 쓰면 컴파일 오류. 이런 경우에는 제네릭타입을 여러개 선언해 사용한다.

구체화 과정
1. mySwap(1, 2) 를 컴파일 할 때, mySwap() 함수를 찾고
2. 템플릿으로 선언된 mySwap() 함수를 발견하여
3. int 형으로 구체화한 소스코드를 만들고
4. 해당 소스코드를 컴파일한 후, 컴파일된 함수를 호출하도록 컴파일한다. (즉, 템플릿은 "컴파일 되지 않는다!!!")

** 템플릿은 소프트웨어의 생선성과 유연성을 높이는 대신, 컴파일 오류메세지가 빈약해 디버깅이 힘들고, 포팅에 취약하다.
** 템플릿을 사용하여 소프트웨어를 만드는 것을, 제네릭 프로그래밍이라 한다.
** 제네릭은 메크로와 달리, side-effect의 우려가 적고, 사용하기 쉽다.

*** 중요!! ***
만약 제네릭함수와 똑같은 이름의 함수가 있다면, 컴파일러는 해당 함수를 먼저 가져온다.
즉 중복 함수가 제네릭 함수보다 우선순위가 높아, 컴파일러가 우선적으로 바인딩한다.

** 템플릿 함수에도 디폴트 매개변수를 쓸 수 있다.
template <class T1, class T2>
f(T1 & a, T2 & b, int c = 1) {...}
이런 식으로, 물론 제네릭타입에는 디폴트 매개변수를 쓸 수 없다. (디폴트 값을 넣는다는 것 자체가, 해당 값의 데이터타입으로 정해져있다는 뜻이므로)

=====================================================================================
제네릭 클래스 = 클래스의 내부 멤버로 제네릭타입 멤버를 가지는 클래스
클래스의 선언부, 구현부를 모두 template로 선언한다.

template <class T>
class myStack {
  int tos;
  T data[100];
public:
  myStack();
  void push(T element);
  T pop();
};

스택에 저장하는 데이터의 유형을 일반화 하였다.
제네릭 클래스 구현부에서는 클래스명인 myStack으로 구현하는 것이 아닌, "myStack<T>" 를 사용하여 구현해야한다.
물론 멤버 함수의 구현부 마다 template 키워드 역시 넣어줘야한다.
template <class T>
void myStack<T>::push(T element) {...}

제네릭 클래스를 구체화 할 때는, <> 안에 데이터 타입을 넣어주면 된다.
myStack<int> iStack;
myStack<double> dStack;

구체화 과정은 제네릭 함수와 비슷하다.
컴파일러가 템플릿에 해당 타입을 넣어 '클래스 소스코드'를 만들고  컴파일 -> 해당 소스로 객체 생성

일반 함수의 매개변수로 제네릭 클래스를 넣을 수도 있다.
void funct(myStack<int> stack, int size) {}

제네릭 클래스에 들어가는 타입이 일반화되길 원한다면?
template <class T>
void funct(myStack<T> stack, int size) {}

여러개의 타입을 가지는 제네릭 클래스 역시 가능하다.
template <class T1, class T2>
class MyPair {
  T1 data1;
  T2 data2;
}

====================================================================
C++에서는 일부 유용한 자료구조나 함수들을 미리 라이브러리화 시켜두었다. => STL ( standard template library )
1. 컨테이너 = 데이터를 저장하고 담아두는 자료구조 구현 클래스 (vector, map, set, ,,,)
2. iterator = 컨테이너의 원소들을 순회 접근하기 위한 반복자, 컨테이너 원소에 대한 포인터이다. (읽기만 가능하게하려면 const, 거꾸로 순회하려면 reverse)
3. 알고리즘 = 컨테이너 원소의 복사, 검색, 삭제, 정렬 등을 구현한 템플릿 함수이다. " 컨테이너 클래스의 멤버 함수가 아니다! "

STL은 std 이름공간에 작성되었으므로, using namespace std; 키워드가 필요하다.

* 벡터
삽입 = push_back()
읽기 = at(int index) 또는 [] 연산자
크기 = size()
원소 삭제 = iterator를 활용. erase(vector<T>::iterator it); 해당 이터레이터가 가리키는 원소 삭제 후, 재배열
원소 삽입 = iterator를 활용. insert(vector<T>::iterator it, T element); 해당 이터레이터가 가리키는 위치에 원소 삽입

* 벡터의 이터레이터
vector<int> v;
vector<int>::iterator it;
it = v.begin(); // 이터레이터가 벡터의 첫번째 원소를 가리키도록 함.
it = v.end(); // 이터레이터가 벡터의 마지막 원소 "다음 차례의" 원소를 가리키도록 함.
it++; // 이터레이터가 다음 차례의 원소를 가리키도록 함
int a = *it; //현재 이터레이터가 가리키는 원소값 읽기
*it = 5; // 현재 이터레이터가 가리키는 원소에 쓰기

이터레이터를 활용한 순회
for (it = v.begin(); it != v.end(); it++) {
  cout << *it << ' ';
}

* 맵
벡터가 정수 인덱스의 순서로 값을 가져오는 것과 달리, 맵은 임의 타입의 임의 값을 키로하여 값을 가져온다.
삽입 = insert(pair<> & element) // dict.(make_pair("hi", "hello")); 와 같이 사용 pair 객체를 넘겨받는다. 또는
dict["hi"] = "hello" 와 같이 [] 연산자로 삽입 가능

검색 = at(key_type) // 해당 키가 가리키는 값을 리턴. 역시 dict[key] 로 값을 읽을 수 있다.
탐색 = find(key_type) // 해당 키가 가리키는 원소가 있는 "이터레이터"를 반환, 만약 값이 없으면 dict.end()와 같은 이터레이터 반환

* 컨테이너 정렬과 알고리즘
<algorithm> 헤더 선언 후, 전역함수로 선언된 알고리즘 템플릿함수를 사용할 수 있다.
sort(v.begin(), v.end()); => 첫 원소부터 마지막 원소까지 정렬

==============================================================================================
*** 중요!!! *** 
* auto와 람다식

auto => 컴파일러에게 형을 자동으로 결정하도록 하는 것.
auto a = 1; // int로 자동 결정.
auto pi = 3.14; // double로 자동 결정.

auto *p = &a; // int의 포인터
auto p = &a;  // 이렇게 해도 int의 포인터

auto & refa = a; // 이렇게 하면 int & 의 참조
auto refa2 = a;  // 이렇게 하면 물론 int 로 인식한다.

auto refa3 = refa; // 그러나 놀랍게도 이렇게 하면 auto가 int형으로 인식한다. 책에는 int & 으로 인식한다고 되어있지만,,,
auto & refa4 = refa; // 이렇게 해야 참조변수로 인식한다.

이런 타입 추론은 '함수의 반환형' 에서도 똑같이 일어난다.
int f() { return 1; }
auto returnValue = f(); // returnValue 는 int형

이걸 STL에 적용하면 귀찮게 vector<int>::iterator 를 선언할 필요 없이
auto it = v.begin(); 하면 된다.

** 람다식 **
익명 함수를 만드는게 람다식이다.
[외부 변수를 갖다 쓰는 캡쳐리스트] (매개변수 리스트) -> 리턴타입 ( = 생략가능) { 함수 구현부 }

[](int x, int y) -> int { return x+y; } 요런식으로 쓸 수 있다.

선언과 동시에 호출할 때는 [] (int x, int y) { return x+y; } (2, 3) 이렇게 선언부 오른쪽에 () 에 실인자값을 넣어주면 된다.
캡쳐리스트에는 [변수명], [&참조변수], [=] = 모든변수, [&] = 모든 참조변수 이런식으로 써서, 외부 변수를 끌어다 쓸 수 있다.

캡쳐리스트에 없는 변수를 쓰면 오류발생
캡쳐리스트에 변수 여러개 넣으려면 , 로 나열하면 된다. [a, b, c] 이런 식으로
섞어 쓸수도 있다.
[a, b, &result]

  int a = 1;
	int b = 2;
	int result;
	int& ref = result;
	cout << [a, b, &](int x, int y) { return ref = x + y + a + b; } (2, 3);

이렇게 섞어 쓰는건 안된다.

  cout << [=, &](int x, int y) { return ref = x + y + a + b; } (2, 3);

이것도 안됨.

  cout << [=, &ref](int x, int y) { return ref = x + y + a + b; } (2, 3);

이건 되고

  cout << [&](int x, int y) { return ref = x + y; } (2, 3);

이것 또 된다. & 는 반드시 단독으로 써야하는 것 같다.


람다식을 변수에 저장해서 호출할 수 있다. 이때 변수의 타입은 컴파일러가 정하기 때문에, 반드시 auto로 써야한다.
  auto print = [&](int x, int y) { return ref = x + y; }; // 변수에 저장하므로 세미콜론 필요.
호출은 print(2,3); 과 같이 평소 함수처럼한다.

STL과 람다식을 섞어쓸 수 있다.
for_each() 는 벡터의 이터레이터를 인자로받아, 해당 범위를 탐색하면서 각 원소에 대해 3번째 인자로 온 함수를 호출한다.

vector<int> v = {1,2,3,4,5};
for_each(v.begin(), v.end(), [](int n) {cout << n << ' '}); // int n 매개변수에 자동으로 벡터 원소의 값을 넘긴다.
